Adding bypass to Freescale's Gianfar Ethernet driver (e.g. used by p2020) to forward
network packages directly from the network driver to a userspace application.


diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index ed8ad0fef..5754d21d1 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_FSL_XGMAC_MDIO) += xgmac_mdio.o
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
 obj-$(CONFIG_PTP_1588_CLOCK_GIANFAR) += gianfar_ptp.o
 gianfar_driver-objs := gianfar.o \
+		gianfar_work.o \
 		gianfar_ethtool.o
 obj-$(CONFIG_UCC_GETH) += ucc_geth_driver.o
 ucc_geth_driver-objs := ucc_geth.o ucc_geth_ethtool.o
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 7f837006b..b4f9e66b8 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -152,7 +152,7 @@ MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
 
-static void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp,
+void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp,
 			    dma_addr_t buf)
 {
 	u32 lstatus;
@@ -209,6 +209,10 @@ static void gfar_init_bds(struct net_device *ndev)
 		rx_queue->next_to_use = 0;
 		rx_queue->next_to_alloc = 0;
 
+		if (likely(priv->is_work)) {
+			work_alloc_rx_buffs(rx_queue, gfar_rxbd_unused(rx_queue));
+		}
+		else
 		/* make sure next_to_clean != next_to_use after this
 		 * by leaving at least 1 unused descriptor
 		 */
@@ -233,6 +237,10 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	for (i = 0; i < priv->num_tx_queues; i++)
 		priv->total_tx_ring_size += priv->tx_queue[i]->tx_ring_size;
 
+	if (likely(priv->is_work)) {
+		work_verify_rx_queue(priv);
+	}
+
 	priv->total_rx_ring_size = 0;
 	for (i = 0; i < priv->num_rx_queues; i++)
 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
@@ -284,11 +292,18 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
 		rx_queue = priv->rx_queue[i];
+		if (likely(priv->is_work)) {
+			work_allocate_buffer(rx_queue);
+			if (!rx_queue->rx_pktbuff)
+				goto cleanup;
+		}
+		else {
 		rx_queue->rx_buff = kcalloc(rx_queue->rx_ring_size,
 					    sizeof(*rx_queue->rx_buff),
 					    GFP_KERNEL);
 		if (!rx_queue->rx_buff)
 			goto cleanup;
+		}
 	}
 
 	gfar_init_bds(ndev);
@@ -578,8 +593,12 @@ static void gfar_free_rx_queues(struct gfar_private *priv)
 {
 	int i;
 
-	for (i = 0; i < priv->num_rx_queues; i++)
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		if (likely(priv->is_work)) {
+			work_free_buffer(priv->rx_queue[i]);
+		}
 		kfree(priv->rx_queue[i]);
+	}
 }
 
 static void unmap_group_regs(struct gfar_private *priv)
@@ -819,6 +838,11 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 	if (err)
 		goto tx_alloc_failed;
 
+	if (ofdev && of_device_is_compatible(ofdev->dev.of_node, "gianfar-work")) {
+		priv->is_work = 1;
+		printk(KERN_NOTICE "Using WORK's gianfar driver.\n");
+	}
+
 	err = gfar_alloc_rx_queues(priv);
 	if (err)
 		goto rx_alloc_failed;
@@ -1160,7 +1184,7 @@ void gfar_mac_reset(struct gfar_private *priv)
 
 	/* Initialize the max receive frame/buffer lengths */
 	gfar_write(&regs->maxfrm, GFAR_JUMBO_FRAME_SIZE);
-	gfar_write(&regs->mrblr, GFAR_RXB_SIZE);
+	gfar_write(&regs->mrblr, priv->is_work ? GFAR_JUMBO_FRAME_SIZE : GFAR_RXB_SIZE);
 
 	/* Initialize the Minimum Frame Length Register */
 	gfar_write(&regs->minflr, MINFLR_INIT_SETTINGS);
@@ -1465,6 +1489,15 @@ static int gfar_probe(struct platform_device *ofdev)
 		netdev_info(dev, "TX BD ring size for Q[%d]: %d\n",
 			    i, priv->tx_queue[i]->tx_ring_size);
 
+	if (likely(priv->is_work)) {
+		err = work_create_fs(dev);
+		if (err != 0) return err;
+
+		for (i = 0; i < priv->num_rx_queues; i++) {
+			err = work_setup_timer(priv->rx_queue[i]);
+		}
+	}
+
 	return 0;
 
 register_fail:
@@ -2050,8 +2083,14 @@ static void free_skb_resources(struct gfar_private *priv)
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
 		rx_queue = priv->rx_queue[i];
+		if (likely(priv->is_work)) {
+			work_free_rx_queue(rx_queue);
+			return ;
+		}
+		else {
 		if (rx_queue->rx_buff)
 			free_skb_rx_queue(rx_queue);
+		}
 	}
 
 	dma_free_coherent(priv->dev,
@@ -2790,7 +2829,7 @@ static bool gfar_new_page(struct gfar_priv_rx_q *rxq, struct gfar_rx_buff *rxb)
 	return true;
 }
 
-static void gfar_rx_alloc_err(struct gfar_priv_rx_q *rx_queue)
+void gfar_rx_alloc_err(struct gfar_priv_rx_q *rx_queue)
 {
 	struct gfar_private *priv = netdev_priv(rx_queue->ndev);
 	struct gfar_extra_stats *estats = &priv->extra_stats;
@@ -3101,6 +3140,8 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 		u32 lstatus;
 
 		if (cleaned_cnt >= GFAR_RX_BUFF_ALLOC) {
+			if (likely(priv->is_work)) work_alloc_rx_buffs(rx_queue, cleaned_cnt);
+			else
 			gfar_alloc_rx_buffs(rx_queue, cleaned_cnt);
 			cleaned_cnt = 0;
 		}
@@ -3113,10 +3154,19 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 		/* order rx buffer descriptor reads */
 		rmb();
 
+		if (likely(priv->is_work)) {
+			skb = work_get_next_rxbuff(rx_queue, lstatus, skb);
+			if (unlikely(skb == WORK_INVALID_SKBUFF)) {
+				skb = NULL;
+				break;
+			}
+		}
+		else {
 		/* fetch next to clean buffer from the ring */
 		skb = gfar_get_next_rxbuff(rx_queue, lstatus, skb);
 		if (unlikely(!skb))
 			break;
+		}
 
 		cleaned_cnt++;
 		howmany++;
@@ -3140,6 +3190,11 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 			continue;
 		}
 
+		// Continue at top, when packet was consumed by skippy
+		if (likely(priv->is_work && skb == NULL)) {
+			continue;
+		}
+
 		/* Increment the number of packets */
 		total_pkts++;
 		total_bytes += skb->len;
@@ -3160,8 +3215,11 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 	rx_queue->stats.rx_packets += total_pkts;
 	rx_queue->stats.rx_bytes += total_bytes;
 
-	if (cleaned_cnt)
+	if (cleaned_cnt) {
+		if (likely(priv->is_work)) work_alloc_rx_buffs(rx_queue, cleaned_cnt);
+		else
 		gfar_alloc_rx_buffs(rx_queue, cleaned_cnt);
+	}
 
 	/* Update Last Free RxBD pointer for LFC */
 	if (unlikely(priv->tx_actual_en)) {
@@ -3779,6 +3837,10 @@ static const struct of_device_id gfar_match[] =
 		.compatible = "gianfar",
 	},
 	{
+		.type = "network",
+		.compatible = "gianfar-work",
+	},
+	{
 		.compatible = "fsl,etsec2",
 	},
 	{},
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 5aa814799..dfa8bf639 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -46,6 +46,8 @@
 #include <linux/workqueue.h>
 #include <linux/ethtool.h>
 
+#include "gianfar_work.h"
+
 struct ethtool_flow_spec_container {
 	struct ethtool_rx_flow_spec fs;
 	struct list_head list;
@@ -1056,6 +1058,11 @@ struct gfar_priv_rx_q {
 	unsigned char rxcoalescing;
 	unsigned long rxic;
 	dma_addr_t rx_bd_dma_base;
+
+	struct work_priv_rx_pkt *rx_pktbuff __aligned(SMP_CACHE_BYTES);
+	struct timer_list rx_timer;
+	int starving;
+	u32 overload_drops;
 };
 
 enum gfar_irqinfo_id {
@@ -1203,6 +1210,16 @@ struct gfar_private {
 	/*Filer table*/
 	unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 	unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
+
+	int is_work;
+	unsigned char f_mac[ETH_ALEN];  // Device MAC
+	__be32 f_ipv4;                  // Device IPv4
+	__be16 tsi_dport1;              // UDP port for TSI Stream 1
+	__be32 tsi_dest_addr1;          // Destination IPv4 for TSI Stream 1 (unicast and multicast)
+	__be16 tsi_dport2;              // UDP port for TSI Stream 2
+	__be32 tsi_dest_addr2;          // Destination IPv4 for TSI Stream 2 (unicast and multicast)
+	__be16 bbi_dport1;              // UPD port for BBI Stream 1
+	__be16 bbi_dport2;              // UPD port for BBI Stream 2
 };
 
 
diff --git a/drivers/net/ethernet/freescale/gianfar_work.c b/drivers/net/ethernet/freescale/gianfar_work.c
new file mode 100644
index 000000000..00ac37a7f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/gianfar_work.c
@@ -0,0 +1,999 @@
+/*
+ * drivers/net/ethernet/freescale/gianfar_work.h
+ *
+ * WORK's Supplement for Gianfar Ethernet Driver
+ *
+ * Author: Karl Krach <karl.krach@work-microwave.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+
+#include "gianfar_work.h"
+#include "gianfar.h"
+
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/etherdevice.h>
+#include <linux/proc_fs.h>
+
+
+// Reusing functions from gianfar.c
+void gfar_rx_alloc_err(struct gfar_priv_rx_q *rx_queue);
+void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp, dma_addr_t buf);
+
+
+#define RX_RING_SIZE (4096) // is about 36MB buffer-size
+
+
+static int work_buffer_open(struct inode *node, struct file *file) {
+	struct gfar_private *priv = PDE_DATA(node);
+	struct gfar_priv_rx_q *rx_queue = priv->rx_queue[0];
+
+	if (!rx_queue || !rx_queue->rx_pktbuff) {
+		printk(KERN_ERR "%s WORK: Device not ready!\n", __func__);
+		return -ENODEV;
+	}
+	file->private_data = priv;
+
+	return 0;
+}
+
+static ssize_t work_buffer_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = file->private_data;
+	struct gfar_priv_rx_q *rx_queue = priv->rx_queue[0];
+	size_t buf_size = rx_queue->rx_ring_size * sizeof(rx_queue->rx_pktbuff[0]);
+	size_t available = buf_size - *ppos;
+	size_t to_copy = size > available ? available : size;
+	int not_copied;
+
+	if (*ppos >= buf_size) return 0;
+
+	not_copied = copy_to_user(buf, (char*)(rx_queue->rx_pktbuff) + *ppos, to_copy);
+	*ppos += to_copy - not_copied;
+
+	return to_copy - not_copied;
+}
+
+static int work_buffer_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static int work_buffer_mmap_fault(struct vm_fault *vmf) {
+	struct gfar_private *priv = vmf->vma->vm_private_data;
+	struct gfar_priv_rx_q *rx_queue;
+	pgoff_t pgoff = vmf->pgoff;
+	struct page *page;
+
+	if (priv->num_rx_queues < 1) {
+		printk(KERN_ERR "%s WORK: Rx-queue missing!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+	if (priv->num_rx_queues > 1) {
+		printk(KERN_ERR "%s WORK: Invalid configuration with more than one rx-queue!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+
+	rx_queue = priv->rx_queue[0];
+	if (!rx_queue || !rx_queue->rx_pktbuff) {
+		printk(KERN_ERR "%s WORK: Device not ready!\n", __func__);
+		return VM_FAULT_MAJOR;
+	}
+
+	if ((pgoff << PAGE_SHIFT) > (rx_queue->rx_ring_size * sizeof(rx_queue->rx_pktbuff[0]))) {
+		printk(KERN_ERR "%s WORK: Given offset extends mapped area!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+
+	page = virt_to_page((char*)(rx_queue->rx_pktbuff) + (pgoff << PAGE_SHIFT));
+	if (!page) {
+		printk(KERN_ERR "%s: Failed to map offset 0x%lx!\n",
+		       __func__, (pgoff << PAGE_SHIFT));
+		return VM_FAULT_SIGBUS;
+	}
+
+	/* increment the reference count of this page */
+	get_page(page);
+	vmf->page = page;
+
+	return 0;
+}
+
+static struct vm_operations_struct work_buffer_mmap_vm_ops = {
+	.fault = work_buffer_mmap_fault,
+};
+
+static int work_buffer_mmap(struct file *f, struct vm_area_struct *vma) {
+	unsigned long size = vma->vm_end - vma->vm_start;
+	struct gfar_private *priv = f->private_data;
+
+	if (size != (RX_RING_SIZE * sizeof(priv->rx_queue[0]->rx_pktbuff[0]))) {
+		printk(KERN_ERR "Memory map size is %lu instead of %u bytes!\n",
+		       size, RX_RING_SIZE * sizeof(priv->rx_queue[0]->rx_pktbuff[0]));
+		return -EINVAL;
+	}
+
+	vma->vm_ops = &work_buffer_mmap_vm_ops;
+	vma->vm_private_data = priv;
+
+	return 0;
+}
+
+static const struct file_operations work_buffer_fops = {
+	.open = &work_buffer_open,
+	.read = &work_buffer_read,
+	.release = &work_buffer_close,
+	.mmap = &work_buffer_mmap,
+};
+
+
+
+
+
+
+
+static int work_next_to_use_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_next_to_use_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	struct gfar_priv_rx_q *rx_queue = priv->rx_queue[0];
+	char buffer[128];
+	int to_copy;
+
+	to_copy = snprintf(buffer, size-1, "%u", rx_queue->next_to_use);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+static ssize_t work_next_to_use_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	return 0;
+}
+static int work_next_to_use_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_next_to_use_fops = {
+	.open = &work_next_to_use_open,
+	.read = &work_next_to_use_read,
+	.write = &work_next_to_use_write,
+	.release = &work_next_to_use_close,
+};
+
+
+
+
+
+
+
+
+static int work_next_to_clean_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_next_to_clean_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	struct gfar_priv_rx_q *rx_queue = priv->rx_queue[0];
+	char buffer[128];
+	int to_copy;
+
+	if (*ppos != 0) return 0;
+
+	to_copy = snprintf(buffer, size-1, "%u", rx_queue->next_to_clean);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+static ssize_t work_next_to_clean_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	return 0;
+}
+static int work_next_to_clean_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_next_to_clean_fops = {
+	.open = &work_next_to_clean_open,
+	.read = &work_next_to_clean_read,
+	.write = &work_next_to_clean_write,
+	.release = &work_next_to_clean_close,
+};
+
+
+
+
+
+
+static ssize_t work_ipv4_to_string(__be32 *ipv4, char __user *buf, size_t size, loff_t *ppos) {
+	char buffer[128];
+	int to_copy;
+
+	to_copy = snprintf(buffer, size-1, "%d.%d.%d.%d",(*ipv4 >> 24), (*ipv4 >> 16) & 0xFF,
+	                   (*ipv4 >> 8) & 0xFF, *ipv4 & 0xFF);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+
+static ssize_t work_string_to_ipv4(__be32 *ipv4, const char __user *buf, size_t size) {
+	char buffer[128], tmp;
+	int ip[4];
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if (size >= 7 && sscanf(buffer, "%d.%d.%d.%d%c", &ip[0], &ip[1], &ip[2], &ip[3], &tmp) >= 4) {
+		*ipv4 = 0;
+		*ipv4 |= (ip[0] & 0xFF) << 24;
+		*ipv4 |= (ip[1] & 0xFF) << 16;
+		*ipv4 |= (ip[2] & 0xFF) << 8;
+		*ipv4 |= (ip[3] & 0xFF);
+
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Wrong IP-Format! Expecting XXX.XXX.XXX.XXX\n");
+		return -EINVAL;
+	}
+}
+
+
+
+
+
+static int work_ipv4_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_ipv4_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	return work_ipv4_to_string(&priv->f_ipv4, buf, size, ppos);
+}
+static ssize_t work_ipv4_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	int result = work_string_to_ipv4(&priv->f_ipv4, buf, size);
+//	printk(KERN_NOTICE "WORK: Setting interface IP to %d.%d.%d.%d\n",
+//	       (priv->f_ipv4 >> 24),
+//	       (priv->f_ipv4 >> 16) & 0xFF,
+//	       (priv->f_ipv4 >>  8) & 0xFF,
+//	       (priv->f_ipv4      ) & 0xFF);
+	return result;
+}
+static int work_ipv4_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_ipv4_fops = {
+	.open = &work_ipv4_open,
+	.read = &work_ipv4_read,
+	.write = &work_ipv4_write,
+	.release = &work_ipv4_close,
+};
+
+
+
+static int work_mac_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_mac_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+	int to_copy;
+
+	if (*ppos != 0) return 0;
+
+	to_copy = snprintf(buffer, size-1, "%02x:%02x:%02x:%02x:%02x:%02x",
+	                   priv->f_mac[0], priv->f_mac[1], priv->f_mac[2],
+	                   priv->f_mac[3], priv->f_mac[4], priv->f_mac[5]);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+static ssize_t work_mac_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128], tmp;
+	int mac[ETH_ALEN], cnt;
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if (sscanf(buffer,"%x:%x:%x:%x:%x:%x%c",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5],&tmp)>=6) {
+		for (cnt=0; cnt<ETH_ALEN; cnt++) {
+			priv->f_mac[cnt] = mac[cnt] & 0xFF;
+		}
+
+		if (!is_valid_ether_addr(priv->f_mac)) {
+			printk(KERN_ERR "Invalid MAC-Address!\n");
+			memset(priv->f_mac, 0, sizeof(priv->f_mac));
+			return -EINVAL;
+		}
+//		printk(KERN_NOTICE "WORK: Setting interface MAC to %02x:%02x:%02x:%02x:%02x:%02x\n",
+//		       priv->f_mac[0], priv->f_mac[1], priv->f_mac[2],
+//		       priv->f_mac[3], priv->f_mac[4], priv->f_mac[5]);
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Wrong MAC-Format! Expecting XX:XX:XX:XX:XX:XX\n");
+		return -EINVAL;
+	}
+}
+static int work_mac_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_mac_fops = {
+	.open = &work_mac_open,
+	.read = &work_mac_read,
+	.write = &work_mac_write,
+	.release = &work_mac_close,
+};
+
+
+
+static int work_tsi_port1_open(struct inode *node, struct file *file) {
+	return 0;
+}
+
+static ssize_t work_tsi_port1_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+	int to_copy;
+
+	if (*ppos != 0) return 0;
+
+	to_copy = snprintf(buffer, size-1, "%hu", priv->tsi_dport1);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+
+static ssize_t work_tsi_port1_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if(sscanf(buffer, "%hu", &priv->tsi_dport1) == 1) {
+//		printk(KERN_NOTICE "WORK: Setting TSI port 1 to %hu\n", priv->tsi_dport1);
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Error parsing TSI port1!\n");
+		return -EINVAL;
+	}
+}
+
+static int work_tsi_port1_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_tsi_port1_fops = {
+		.open = &work_tsi_port1_open,
+		.read = &work_tsi_port1_read,
+		.write = &work_tsi_port1_write,
+		.release = &work_tsi_port1_close,
+};
+
+
+
+static int work_tsi_dest_addr1_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_tsi_dest_addr1_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	if (*ppos != 0) return 0;
+	return work_ipv4_to_string(&priv->tsi_dest_addr1, buf, size, ppos);
+}
+static ssize_t work_tsi_dest_addr1_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	int result = work_string_to_ipv4(&priv->tsi_dest_addr1, buf, size);
+//	printk(KERN_NOTICE "WORK: Setting TSI destination IP 1 to %d.%d.%d.%d\n",
+//	       (priv->f_ipv4 >> 24),
+//	       (priv->f_ipv4 >> 16) & 0xFF,
+//	       (priv->f_ipv4 >>  8) & 0xFF,
+//	       (priv->f_ipv4      ) & 0xFF);
+	return result;
+}
+static int work_tsi_dest_addr1_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_tsi_dest_addr1_fops = {
+	.open = &work_tsi_dest_addr1_open,
+	.read = &work_tsi_dest_addr1_read,
+	.write = &work_tsi_dest_addr1_write,
+	.release = &work_tsi_dest_addr1_close,
+};
+
+
+
+
+static int work_tsi_port2_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_tsi_port2_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+	int to_copy;
+
+	if (*ppos != 0) return 0;
+
+	to_copy = snprintf(buffer, size-1, "%hu", priv->tsi_dport2);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+
+static ssize_t work_tsi_port2_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if(sscanf(buffer, "%hu", &priv->tsi_dport2) == 1) {
+//		printk(KERN_NOTICE "WORK: Setting TSI port 2 to %hu\n", priv->tsi_dport2);
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Error parsing TSI port2!\n");
+		return -EINVAL;
+	}
+}
+
+static int work_tsi_port2_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_tsi_port2_fops = {
+		.open = &work_tsi_port2_open,
+		.read = &work_tsi_port2_read,
+		.write = &work_tsi_port2_write,
+		.release = &work_tsi_port2_close,
+};
+
+
+static int work_bbi_port1_open(struct inode *node, struct file *file) {
+	return 0;
+}
+
+static ssize_t work_bbi_port1_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+	int to_copy;
+
+	to_copy = snprintf(buffer, size-1, "%hu", priv->bbi_dport1);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+
+static ssize_t work_bbi_port1_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if(sscanf(buffer, "%hu", &priv->bbi_dport1) == 1) {
+//		printk(KERN_NOTICE "WORK: Setting BBI port 1 to %hu\n", priv->bbi_dport1);
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Error parsing BBI port1!\n");
+		return -EINVAL;
+	}
+}
+
+static int work_bbi_port1_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_bbi_port1_fops = {
+		.open = &work_bbi_port1_open,
+		.read = &work_bbi_port1_read,
+		.write = &work_bbi_port1_write,
+		.release = &work_bbi_port1_close,
+};
+
+static int work_bbi_port2_open(struct inode *node, struct file *file) {
+	return 0;
+}
+
+static ssize_t work_bbi_port2_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+	int to_copy;
+
+	to_copy = snprintf(buffer, size-1, "%hu", priv->bbi_dport2);
+	buffer[to_copy] = '\0';
+	to_copy++;
+
+	to_copy -= copy_to_user(buf, buffer + *ppos, to_copy - *ppos);
+	return to_copy - *ppos;
+}
+
+static ssize_t work_bbi_port2_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	char buffer[128];
+
+	if (size >= sizeof(buffer)) return -EMSGSIZE;   // Message too long
+	if (copy_from_user(buffer, buf, size) > 0) {
+		return -EINVAL;
+	}
+	buffer[size] = '\0';
+
+	if(sscanf(buffer, "%hu", &priv->bbi_dport2) == 1) {
+//		printk(KERN_NOTICE "WORK: Setting BBI port 2 to %hu\n", priv->bbi_dport2);
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Error parsing BBI port2!\n");
+		return -EINVAL;
+	}
+}
+
+static int work_bbi_port2_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_bbi_port2_fops = {
+		.open = &work_bbi_port2_open,
+		.read = &work_bbi_port2_read,
+		.write = &work_bbi_port2_write,
+		.release = &work_bbi_port2_close,
+};
+
+
+static int work_tsi_dest_addr2_open(struct inode *node, struct file *file) {
+	return 0;
+}
+static ssize_t work_tsi_dest_addr2_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	if (*ppos != 0) return 0;
+	return work_ipv4_to_string(&priv->tsi_dest_addr2, buf, size, ppos);
+}
+static ssize_t work_tsi_dest_addr2_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfar_private *priv = PDE_DATA(file_inode(file));
+	int result = work_string_to_ipv4(&priv->tsi_dest_addr2, buf, size);
+//	printk(KERN_NOTICE "WORK: Setting TSI destination IP 2 to %d.%d.%d.%d\n",
+//	       (priv->f_ipv4 >> 24),
+//	       (priv->f_ipv4 >> 16) & 0xFF,
+//	       (priv->f_ipv4 >>  8) & 0xFF,
+//	       (priv->f_ipv4      ) & 0xFF);
+	return result;
+}
+static int work_tsi_dest_addr2_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static const struct file_operations work_tsi_dest_addr2_fops = {
+	.open = &work_tsi_dest_addr2_open,
+	.read = &work_tsi_dest_addr2_read,
+	.write = &work_tsi_dest_addr2_write,
+	.release = &work_tsi_dest_addr2_close,
+};
+
+
+
+int work_create_fs(struct net_device *dev) {
+#ifdef CONFIG_PROC_FS
+	struct gfar_private *priv = netdev_priv(dev);
+	char buf[128];
+
+	sprintf(buf, "work_%s_buf", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_buffer_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+
+	sprintf(buf, "work_%s_next_to_use", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_next_to_use_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+	sprintf(buf, "work_%s_next_to_clean", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_next_to_clean_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+
+	sprintf(buf, "work_%s_ipv4", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_ipv4_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_mac", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_mac_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_tsi_dport1", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_tsi_port1_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_tsi_dest_addr1", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_tsi_dest_addr1_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_tsi_dport2", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_tsi_port2_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_tsi_dest_addr2", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_tsi_dest_addr2_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//		printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_bbi_dport1", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_bbi_port1_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+//	else {
+//			printk(KERN_NOTICE "WORK: /proc/net/%s entry created!\n",buf);
+//	}
+	sprintf(buf, "work_%s_bbi_dport2", dev->name);
+	if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_bbi_port2_fops, priv)) {
+		printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+		return -ENOENT;
+	}
+
+	return 0;
+#endif  /* CONFIG_PROC_FS */
+}
+
+static void work_rx_timer_cb(struct timer_list* t) {
+	struct gfar_priv_rx_q *rx_queue = from_timer(rx_queue, t, rx_timer);
+	struct gfar_priv_grp *grp = rx_queue->grp;
+	if (rx_queue->starving) {
+		if (napi_reschedule(&grp->napi_rx)) {
+			rx_queue->starving = 0;
+		}
+	}
+	mod_timer(&rx_queue->rx_timer, jiffies + STARVING_RATE);
+}
+
+int work_setup_timer(struct gfar_priv_rx_q * rx_queue) {
+	timer_setup(&rx_queue->rx_timer, work_rx_timer_cb, 0);
+	mod_timer(&rx_queue->rx_timer, jiffies + STARVING_RATE);
+	return 0;
+}
+
+/** Returns true when address is multicast address (not broadcast) */
+static inline bool ipv4_is_multicast_only(__be32 addr) {
+	return (addr & htonl(0xf0000000)) == htonl(0xe0000000);
+}
+
+/** Returns true when address is non-routed (local) multicast */
+static inline bool ipv4_is_multicast_local(__be32 addr) {
+	return (addr & htonl(0xffffff00)) == htonl(0xe0000000);  // matches for 224.0.0.*
+}
+
+/** Returns true when address is multicast address (not broadcast) */
+static inline bool ether_is_multicast_only(const char* mac) {
+	return mac[0] == 0x01;
+}
+
+static inline bool matches_tsi1_port(const struct gfar_private *priv, uint16_t port) {
+	return ntohs(port) == priv->tsi_dport1;
+}
+
+static inline bool matches_tsi1_addr(const struct gfar_private *priv, __be32 addr) {
+	return addr == priv->tsi_dest_addr1;
+}
+
+static inline bool matches_tsi2_port(const struct gfar_private *priv, uint16_t port) {
+	return ntohs(port) == priv->tsi_dport2;
+}
+
+static inline bool matches_tsi2_addr(const struct gfar_private *priv, __be32 addr) {
+	return addr == priv->tsi_dest_addr2;
+}
+
+static inline bool matches_bbi1_port(const struct gfar_private *priv, uint16_t port) {
+	return ntohs(port) == priv->bbi_dport1;
+}
+
+static inline bool matches_bbi2_port(const struct gfar_private *priv, uint16_t port) {
+	return ntohs(port) == priv->bbi_dport2;
+}
+
+static inline bool ipv4_is_our_ip(const struct gfar_private *priv, __be32 addr) {
+	return addr == priv->f_ipv4;
+}
+
+static inline int work_classify_packet(const struct gfar_private *priv, const char* eth_pkt) {
+
+	const struct ethhdr *eth = (struct ethhdr *) (eth_pkt);
+	const bool matches_mac = ether_is_multicast_only(eth->h_dest) || ether_addr_equal(eth->h_dest, priv->f_mac);
+
+	// WORK:  Handle only IP packets where MAC=multicast or MAC=our
+	if (eth->h_proto == ETH_P_IP && matches_mac) {
+		const struct iphdr *ipv4 = (struct iphdr *) (eth_pkt + ETH_HLEN);
+
+		// TSI:  TSoIP is only UDP
+		if (ipv4->protocol == IPPROTO_UDP) {
+
+			const struct udphdr *udp = (struct udphdr *) (ipv4 + 1);
+
+			// TSI1:  if TSI1 is enabled and PORT=matching and IP=matching-TSI1-IP
+			if (priv->tsi_dport1 != 0 && matches_tsi1_port(priv, udp->dest) && matches_tsi1_addr(priv, ipv4->daddr)) {
+
+				return NET_BYPASS_TYPE_TSI1;
+			}
+
+			// TSI2:  if TSI2 is enabled and PORT=matching and IP=matching-TSI2-IP
+			if (priv->tsi_dport2 != 0 && matches_tsi2_port(priv, udp->dest) && matches_tsi2_addr(priv, ipv4->daddr)) {
+
+				return NET_BYPASS_TYPE_TSI2;
+			}
+
+			// BBI1:  if BBI is enabled and PORT=matching
+			if (priv->bbi_dport1 != 0 && matches_bbi1_port(priv, udp->dest)) {
+				return NET_BYPASS_TYPE_BBI1;
+			}
+			// BBI2:  if BBI is enabled and PORT=matching
+			if (priv->bbi_dport2 != 0 && matches_bbi2_port(priv, udp->dest)) {
+				return NET_BYPASS_TYPE_BBI2;
+			}
+		}
+
+
+		// IP-BROADCAST:  If addressed to IP=!our
+		if (ipv4_is_our_ip(priv, ipv4->daddr) == false && ipv4_is_multicast_local(ipv4->daddr) == false) {
+			return NET_BYPASS_TYPE_IP;
+		}
+	}
+
+	return NET_BYPASS_TYPE_INVALID;
+}
+
+int work_allocate_buffer(struct gfar_priv_rx_q * rx_queue) {
+	int i;
+
+	rx_queue->rx_pktbuff = kmalloc_array(rx_queue->rx_ring_size, sizeof(rx_queue->rx_pktbuff[0]), GFP_KERNEL | __GFP_ZERO);
+	if (rx_queue->rx_pktbuff == NULL) {
+		printk(KERN_ERR "%s:%d Failed to allocate %d bytes!\n", __FILE__, __LINE__,
+		       rx_queue->rx_ring_size * sizeof(rx_queue->rx_pktbuff[0]));
+		return -ENOMEM;
+	}
+
+	memset(rx_queue->rx_pktbuff, 0, rx_queue->rx_ring_size * sizeof(rx_queue->rx_pktbuff[0]));
+
+	for (i = 0; i < rx_queue->rx_ring_size; i++) {
+		struct work_priv_rx_pkt *pktbuff = &rx_queue->rx_pktbuff[i];
+		pktbuff->status = NET_BYPASS_STATUS_FREE;
+	}
+	return 0;
+}
+
+void work_free_buffer(struct gfar_priv_rx_q *rx_queue) {
+	kfree(rx_queue->rx_pktbuff);
+	rx_queue->rx_pktbuff = NULL;
+}
+
+void work_verify_rx_queue(struct gfar_private *priv) {
+	int i;
+	if (priv->num_rx_queues != 1) {
+		printk(KERN_WARNING "WORK's gianfar driver supports only one rx-queue: %d\n",
+		       priv->num_rx_queues);
+	}
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		struct gfar_priv_rx_q *rx_queue = priv->rx_queue[i];
+		if (rx_queue->rx_ring_size != RX_RING_SIZE) {
+			printk(KERN_INFO "Changing rx-ring-size from %d to %d.\n",
+			       rx_queue->rx_ring_size, RX_RING_SIZE);
+			rx_queue->rx_ring_size = RX_RING_SIZE;
+		}
+	}
+}
+
+void work_free_rx_queue(struct gfar_priv_rx_q *rx_queue)
+{
+	int i;
+	struct rxbd8 *rxbdp = rx_queue->rx_bd_base;
+
+	if (rx_queue->skb)
+		dev_kfree_skb(rx_queue->skb);
+
+	for (i = 0; i < rx_queue->rx_ring_size; i++) {
+		struct work_priv_rx_pkt *pktbuff = &rx_queue->rx_pktbuff[i];
+
+		rxbdp->lstatus = 0;
+		rxbdp->bufPtr = 0;
+		rxbdp++;
+
+		dma_unmap_single(rx_queue->dev, pktbuff->dma, sizeof(pktbuff->frame), DMA_FROM_DEVICE);
+	}
+
+	work_free_buffer(rx_queue);
+}
+
+// replacement of gfar_new_page
+static bool work_new_page(struct gfar_priv_rx_q *rx_queue, struct work_priv_rx_pkt *pktbuff)
+{
+	dma_addr_t addr;
+
+	addr = dma_map_single(rx_queue->dev, pktbuff->frame, sizeof(pktbuff->frame), DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(rx_queue->dev, addr))) {
+		return false;
+	}
+
+	pktbuff->dma = addr;
+	pktbuff->status = NET_BYPASS_STATUS_DMA;
+	pktbuff->size = 0;
+
+	return true;
+}
+
+// replacement of gfar_alloc_rx_buffs
+void work_alloc_rx_buffs(struct gfar_priv_rx_q *rx_queue, int alloc_cnt)
+{
+	struct rxbd8 *bdp;
+	struct work_priv_rx_pkt *pktbuff;
+	int i;
+
+	i = rx_queue->next_to_use;
+	bdp = &rx_queue->rx_bd_base[i];
+
+	while (alloc_cnt--) {
+		pktbuff = &rx_queue->rx_pktbuff[i];
+
+		// Do not reuse buffer, when it's still in use by the application
+		if (pktbuff->status != NET_BYPASS_STATUS_FREE) {
+//			printk_10s(KERN_ERR "Status(%d of %d) is 0x%x instead of 0x%x (free)!\n",
+//			           i, i+alloc_cnt+1, pktbuff->status, NET_BYPASS_STATUS_FREE);
+			rx_queue->starving = 1;
+			break;
+		}
+
+		if (unlikely(!pktbuff->dma)) {
+			if (unlikely(!work_new_page(rx_queue, pktbuff))) {
+				gfar_rx_alloc_err(rx_queue);
+				break;
+			}
+		}
+		pktbuff->status = NET_BYPASS_STATUS_DMA;
+
+		dma_sync_single_range_for_device(rx_queue->dev, pktbuff->dma, 0,
+		                                 sizeof(pktbuff->frame), DMA_FROM_DEVICE);
+
+		/* Setup the new RxBD */
+		gfar_init_rxbdp(rx_queue, bdp, pktbuff->dma);
+
+		/* Update to the next pointer */
+		bdp++;
+
+		if (unlikely(++i == rx_queue->rx_ring_size)) {
+			i = 0;
+			bdp = rx_queue->rx_bd_base;
+		}
+	}
+
+	rx_queue->next_to_use = i;
+	rx_queue->next_to_alloc = i;
+}
+
+// replaces gfar_get_next_rxbuff
+struct sk_buff *work_get_next_rxbuff(struct gfar_priv_rx_q *rx_queue,
+                                     u32 lstatus, struct sk_buff *skb)
+{
+	struct gfar_private *priv = netdev_priv(rx_queue->ndev);
+	struct work_priv_rx_pkt *pktbuff = &rx_queue->rx_pktbuff[rx_queue->next_to_clean];
+	unsigned int size = lstatus & BD_LENGTH_MASK;
+
+
+	if (unlikely(pktbuff->status != NET_BYPASS_STATUS_DMA)) {
+//		if (pktbuff->status == NET_BYPASS_STATUS_USER || pktbuff->status NET_BYPASS_STATUS_KERNEL) {
+//			printk_10s(KERN_NOTICE "Dropping packet because userspace is too slow!\n");
+//		}
+//		else {
+//			printk_10s(KERN_ERR "ERROR: %s: status[%d]=0x%x instead of 0x%x!\n", __func__,
+//			       rx_queue->next_to_clean, pktbuff->status, NET_BYPASS_STATUS_DMA);
+//		}
+		rx_queue->overload_drops ++;
+		rx_queue->starving = 1;
+		return WORK_INVALID_SKBUFF;
+	}
+
+	/* Remove the FCS from the packet length */
+	if (likely(lstatus & BD_LFLAG(RXBD_LAST)))
+		size -= ETH_FCS_LEN;
+
+	dma_sync_single_range_for_cpu(rx_queue->dev, pktbuff->dma, 0, sizeof(pktbuff->frame), DMA_FROM_DEVICE);
+
+	dma_unmap_single(priv->dev, pktbuff->dma,
+	                 sizeof(pktbuff->frame), DMA_FROM_DEVICE);
+
+	pktbuff->offset = 0;
+	if (priv->uses_rxfcb) {
+		pktbuff->offset += GMAC_FCB_LEN;
+	}
+	if (priv->padding) {
+		pktbuff->offset += priv->padding;
+	}
+
+	pktbuff->drops = rx_queue->overload_drops;
+	rx_queue->overload_drops = 0;
+
+	pktbuff->size = size - pktbuff->offset;
+
+	pktbuff->type = work_classify_packet(priv, pktbuff->frame + pktbuff->offset);
+
+	/* Status must be set as the last action! */
+	switch (pktbuff->type) {
+		case NET_BYPASS_TYPE_IP:
+		case NET_BYPASS_TYPE_TSI1:
+		case NET_BYPASS_TYPE_TSI2:
+		case NET_BYPASS_TYPE_BBI1:
+		case NET_BYPASS_TYPE_BBI2:
+			pktbuff->status = NET_BYPASS_STATUS_USER;
+			break;
+
+		case NET_BYPASS_TYPE_INVALID:
+			skb = netdev_alloc_skb(rx_queue->ndev, size);
+			if (!skb) return NULL;
+			memcpy(skb_put(skb, size), pktbuff->frame, size);
+			pktbuff->status = NET_BYPASS_STATUS_KERNEL;
+			break;
+	}
+	return skb;
+}
diff --git a/drivers/net/ethernet/freescale/gianfar_work.h b/drivers/net/ethernet/freescale/gianfar_work.h
new file mode 100644
index 000000000..584d1e961
--- /dev/null
+++ b/drivers/net/ethernet/freescale/gianfar_work.h
@@ -0,0 +1,111 @@
+/*
+ * drivers/net/ethernet/freescale/gianfar_work.h
+ *
+ * WORK's Supplement for Gianfar Ethernet Driver
+ *
+ * Author: Karl Krach <karl.krach@work-microwave.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __GIANFAR_WORK_H
+#define __GIANFAR_WORK_H
+
+#include <linux/kernel.h>
+
+// Forward declarations
+struct net_device;
+struct sk_buff;
+struct gfar_priv_rx_q;
+struct gfar_private;
+
+
+
+#define printk_1s(...) \
+	do { \
+		u64 __now = ktime_get_ns(); \
+		static u64 __last_now = 0 ; \
+		static int __cnt = 0; \
+		__cnt++; \
+		if ((__now - __last_now) > (1*1000*1000*1000LL)) { \
+			printk(__VA_ARGS__); \
+			if (__cnt > 1) { \
+				printk(KERN_ERR " ** %d msgs skipped! **\n", __cnt-1); \
+			} \
+			__cnt = 0; \
+			__last_now = __now; \
+		} \
+	} while (0)
+
+#define printk_10s(...) \
+	do { \
+		u64 __now = ktime_get_ns(); \
+		static u64 __last_now = 0 ; \
+		static int __cnt = 0; \
+		__cnt++; \
+		if ((__now - __last_now) > (10*1000*1000*1000LL)) { \
+			printk(__VA_ARGS__); \
+			if (__cnt > 1) { \
+				printk(KERN_ERR " ** %d msgs skipped! **\n", __cnt-1); \
+			} \
+			__cnt = 0; \
+			__last_now = __now; \
+		} \
+	} while (0)
+
+
+
+
+
+
+/* Up to 8 different packet status */
+#define NET_BYPASS_STATUS_INVALID      (0)         /* Packet is invalid - must not happen! */
+#define NET_BYPASS_STATUS_FREE         (1 << 0)    /* Packet was fully read from userspace */
+#define NET_BYPASS_STATUS_DMA          (1 << 1)    /* Packet is assigned to DMA to be filled */
+#define NET_BYPASS_STATUS_USER         (1 << 2)    /* Packet is filled and for userspace */
+#define NET_BYPASS_STATUS_KERNEL       (1 << 3)    /* Packet is filled and for kernel */
+
+/* Up to 256 different packet types */
+#define NET_BYPASS_TYPE_INVALID        (0)         /* Invalid type */
+#define NET_BYPASS_TYPE_IP             (1)         /* Packet for IP transmission */
+#define NET_BYPASS_TYPE_TSI1           (2)         /* Packet for Transport Stream Input 1 */
+#define NET_BYPASS_TYPE_TSI2           (3)         /* Packet for Transport Stream Input 2 */
+#define NET_BYPASS_TYPE_BBI1           (4)         /* Packet for Baseband Input 1 */
+#define NET_BYPASS_TYPE_BBI2           (5)         /* Packet for Baseband Input 2 */
+
+
+
+
+
+#define WORK_JUMBO_BUFFER_SIZE                 9728
+
+#define WORK_INVALID_SKBUFF ((struct sk_buff *)0x1)
+
+#define STARVING_RATE   (HZ/200)
+
+struct work_priv_rx_pkt {
+	uint8_t status;
+	uint8_t type;
+	int32_t size;
+	int32_t offset;
+	dma_addr_t dma;    // uint64_t due to CONFIG_ARCH_DMA_ADDR_T_64BIT
+	uint32_t drops;
+	uint8_t reserved[128-2*sizeof(uint8_t)-3*sizeof(uint32_t)-sizeof(dma_addr_t)];
+	uint8_t frame[WORK_JUMBO_BUFFER_SIZE];
+} __attribute__((packed));
+
+int work_create_fs(struct net_device *dev);
+int work_setup_timer(struct gfar_priv_rx_q *rx_queue);
+int work_consume_to_skippy(struct net_device *dev, const struct sk_buff *skb);
+int work_allocate_buffer(struct gfar_priv_rx_q *rx_queue);
+void work_free_buffer(struct gfar_priv_rx_q *rx_queue);
+void work_verify_rx_queue(struct gfar_private *priv);
+void work_free_rx_queue(struct gfar_priv_rx_q *rx_queue);
+void work_alloc_rx_buffs(struct gfar_priv_rx_q *rx_queue, int alloc_cnt);
+struct sk_buff *work_get_next_rxbuff(struct gfar_priv_rx_q *rx_queue, u32 lstatus, struct sk_buff *skb);
+
+
+#endif // __GIANFAR_WORK_H
