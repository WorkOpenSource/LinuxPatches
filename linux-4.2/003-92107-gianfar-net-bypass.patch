diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index ff76d4e9dc1b..a67a1aa216b6 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -91,4 +91,34 @@ config GIANFAR
 	  and MPC86xx family of chips, the eTSEC on LS1021A and the FEC
 	  on the 8540.
 
+if GIANFAR
+config GIANFAR_WORK
+	tristate "WORK's Gianfar Ethernet Driver"
+	depends on GIANFAR
+	---help---
+	  This driver is a clone of the 'Gianfar Ethernet' allowing to receive filtered raw
+	  IP data via /proc interface.
+
+if GIANFAR_WORK
+config GIANFAR_WORK_RX_PACKET_STATS_INTERVAL
+	int "Packet statistics interval (0 => disabled, 33 => 8 seconds...)"
+	range 0 128
+	default 0
+	depends on GIANFAR_WORK
+	---help---
+	  Defines the interval, in which the packet statistics are printed to the kernel log.
+	  The value is an exponent of 2.
+
+	  Examples:
+	      0 => disabled
+	     30 => 2^30 ns  =  1.1 seconds
+	     32 => 2^32 ns  =  4.3 seconds
+	     33 => 2^33 ns  =  8.6 seconds
+	     35 => 2^35 ns  = 34.4 seconds
+
+	  (WORK Microwave implementation)
+
+endif # GIANFAR_WORK
+endif # GIANFAR
+
 endif # NET_VENDOR_FREESCALE
diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index 71debd1c18c9..eedf1518fafb 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -12,8 +12,10 @@ obj-$(CONFIG_FS_ENET) += fs_enet/
 obj-$(CONFIG_FSL_PQ_MDIO) += fsl_pq_mdio.o
 obj-$(CONFIG_FSL_XGMAC_MDIO) += xgmac_mdio.o
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
+obj-$(CONFIG_GIANFAR_WORK) += gianfar_work_driver.o
 obj-$(CONFIG_PTP_1588_CLOCK_GIANFAR) += gianfar_ptp.o
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o
+gianfar_work_driver-objs := gianfar_work.o
 obj-$(CONFIG_UCC_GETH) += ucc_geth_driver.o
 ucc_geth_driver-objs := ucc_geth.o ucc_geth_ethtool.o
diff --git a/drivers/net/ethernet/freescale/gianfar_ethtool.c b/drivers/net/ethernet/freescale/gianfar_ethtool.c
index 5b90fcf96265..9e6ea3b6994f 100644
--- a/drivers/net/ethernet/freescale/gianfar_ethtool.c
+++ b/drivers/net/ethernet/freescale/gianfar_ethtool.c
@@ -16,7 +16,7 @@
  *  by reference.
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#define pr_fmt(fmt) KBUILD_BASENAME ": " fmt
 
 #include <linux/kernel.h>
 #include <linux/string.h>
diff --git a/drivers/net/ethernet/freescale/gianfar_work.c b/drivers/net/ethernet/freescale/gianfar_work.c
new file mode 100644
index 000000000000..9963c1c3c68c
--- /dev/null
+++ b/drivers/net/ethernet/freescale/gianfar_work.c
@@ -0,0 +1,3818 @@
+/* drivers/net/ethernet/freescale/gianfar_work.c
+ *
+ * WORK's Gianfar Ethernet Driver
+ * Clone of freescale's Gianfar ethernet driver with added 'shortcut' to stream incomming
+ * network pakets to userspace.
+ *
+ * Author: Andy Fleming
+ * Modified: Karl Krach <karl.krach@work-microwave.com>
+ *
+ * Copyright 2002-2009, 2011-2013 Freescale Semiconductor, Inc.
+ * Copyright 2007 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/net_tstamp.h>
+#include <linux/etherdevice.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+#ifdef CONFIG_PPC
+#include <asm/reg.h>
+#include <asm/mpc85xx.h>
+#endif
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#include "gianfar_work.h"
+
+#define TX_TIMEOUT      (1*HZ)
+
+const char gfarw_driver_version[] = "1.3w";
+
+static int gfarw_enet_open(struct net_device *dev);
+static int gfarw_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void gfarw_reset_task(struct work_struct *work);
+static void gfarw_timeout(struct net_device *dev);
+static int gfarw_close(struct net_device *dev);
+static int gfarw_set_mac_address(struct net_device *dev);
+static int gfarw_change_mtu(struct net_device *dev, int new_mtu);
+static irqreturn_t gfarw_error(int irq, void *dev_id);
+static irqreturn_t gfarw_transmit(int irq, void *dev_id);
+static irqreturn_t gfarw_interrupt(int irq, void *dev_id);
+static void adjust_link(struct net_device *dev);
+static noinline void gfarw_update_link_state(struct gfarw_private *priv);
+static int init_phy(struct net_device *dev);
+static int gfarw_probe(struct platform_device *ofdev);
+static int gfarw_remove(struct platform_device *ofdev);
+static void free_skb_resources(struct gfarw_private *priv);
+static void gfarw_set_multi(struct net_device *dev);
+static void gfarw_set_hash_for_addr(struct net_device *dev, u8 *addr);
+static void gfarw_configure_serdes(struct net_device *dev);
+static int gfarw_poll_rx(struct napi_struct *napi, int budget);
+static int gfarw_poll_tx(struct napi_struct *napi, int budget);
+static int gfarw_poll_rx_sq(struct napi_struct *napi, int budget);
+static int gfarw_poll_tx_sq(struct napi_struct *napi, int budget);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void gfarw_netpoll(struct net_device *dev);
+#endif
+int gfarw_clean_rx_ring(struct gfarw_priv_rx_q *rx_queue, int rx_work_limit);
+static void gfarw_clean_tx_ring(struct gfarw_priv_tx_q *tx_queue);
+static void gfarw_process_frame(struct net_device *dev, struct sk_buff *skb,
+			       int amount_pull, struct napi_struct *napi);
+static void gfarw_halt_nodisable(struct gfarw_private *priv);
+static void gfarw_clear_exact_match(struct net_device *dev);
+static void gfarw_set_mac_for_addr(struct net_device *dev, int num,
+				  const u8 *addr);
+static int gfarw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc");
+MODULE_DESCRIPTION("Gianfar Ethernet Driver / WORK");
+MODULE_LICENSE("GPL");
+
+static void gfarw_init_rxbdp(struct gfarw_priv_rx_q *rx_queue, struct rxbd8 *bdp,
+			    dma_addr_t buf)
+{
+	u32 lstatus;
+
+	bdp->bufPtr = cpu_to_be32(buf);
+
+	lstatus = BD_LFLAG(RXBD_EMPTY | RXBD_INTERRUPT);
+	if (bdp == rx_queue->rx_bd_base + RX_RING_SIZE - 1)
+		lstatus |= BD_LFLAG(RXBD_WRAP);
+
+	gfarw_wmb();
+
+	bdp->lstatus = cpu_to_be32(lstatus);
+}
+
+static int gfarw_init_bds(struct net_device *ndev)
+{
+	struct gfarw_private *priv = netdev_priv(ndev);
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	struct gfarw_priv_tx_q *tx_queue = NULL;
+	struct gfarw_priv_rx_q *rx_queue = NULL;
+	struct txbd8 *txbdp;
+	struct rxbd8 *rxbdp;
+	u32 __iomem *rfbptr;
+	int i, j;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_queue = priv->tx_queue[i];
+		/* Initialize some variables in our dev structure */
+		tx_queue->num_txbdfree = tx_queue->tx_ring_size;
+		tx_queue->dirty_tx = tx_queue->tx_bd_base;
+		tx_queue->cur_tx = tx_queue->tx_bd_base;
+		tx_queue->skb_curtx = 0;
+		tx_queue->skb_dirtytx = 0;
+
+		/* Initialize Transmit Descriptor Ring */
+		txbdp = tx_queue->tx_bd_base;
+		for (j = 0; j < tx_queue->tx_ring_size; j++) {
+			txbdp->lstatus = 0;
+			txbdp->bufPtr = 0;
+			txbdp++;
+		}
+
+		/* Set the last descriptor in the ring to indicate wrap */
+		txbdp--;
+		txbdp->status = cpu_to_be16(be16_to_cpu(txbdp->status) |
+					    TXBD_WRAP);
+	}
+
+	rfbptr = &regs->rfbptr0;
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i];
+		rx_queue->cur_rx = rx_queue->rx_bd_base;
+		rxbdp = rx_queue->rx_bd_base;
+
+		if (i != 0) {
+			printk(KERN_ERR "%s: Invalid queue index %d!\n", __func__, i);
+		}
+
+		for (j=0; j < RX_RING_SIZE; j++) {
+			struct gfarw_priv_rx_pkt *ptkbuff;
+			const int index = (j + rx_queue->rx_currpkt) % RX_RING_SIZE;
+			ptkbuff = &rx_queue->rx_pktbuff[index];
+			ptkbuff->rxbd = rxbdp;
+
+			ptkbuff->status = NET_BYPASS_STATUS_PACKET_IN_DMA;
+			ptkbuff->size = 0;
+
+			ptkbuff->rxbd->bufPtr = cpu_to_be32(dma_map_single(priv->dev, ptkbuff->frame,
+			                                                   sizeof(ptkbuff->frame), DMA_FROM_DEVICE));
+
+			/* Setup the new bdp */
+			gfarw_init_rxbdp(rx_queue, ptkbuff->rxbd, be32_to_cpu(ptkbuff->rxbd->bufPtr));
+
+			rxbdp++;
+		}
+
+		rx_queue->rfbptr = rfbptr;
+		rfbptr += 2;
+	}
+
+	return 0;
+}
+
+static int gfarw_alloc_skb_resources(struct net_device *ndev)
+{
+	void *vaddr;
+	dma_addr_t addr;
+	int i, j, k;
+	struct gfarw_private *priv = netdev_priv(ndev);
+	struct device *dev = priv->dev;
+	struct gfarw_priv_tx_q *tx_queue = NULL;
+	struct gfarw_priv_rx_q *rx_queue = NULL;
+
+	priv->total_tx_ring_size = 0;
+	for (i = 0; i < priv->num_tx_queues; i++)
+		priv->total_tx_ring_size += priv->tx_queue[i]->tx_ring_size;
+
+	priv->total_rx_ring_size = 0;
+	for (i = 0; i < priv->num_rx_queues; i++)
+		priv->total_rx_ring_size += RX_RING_SIZE;
+
+	/* Allocate memory for the buffer descriptors */
+	vaddr = dma_alloc_coherent(dev,
+				   (priv->total_tx_ring_size *
+				    sizeof(struct txbd8)) +
+				   (priv->total_rx_ring_size *
+				    sizeof(struct rxbd8)),
+				   &addr, GFP_KERNEL);
+	if (!vaddr)
+		return -ENOMEM;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_queue = priv->tx_queue[i];
+		tx_queue->tx_bd_base = vaddr;
+		tx_queue->tx_bd_dma_base = addr;
+		tx_queue->dev = ndev;
+		/* enet DMA only understands physical addresses */
+		addr  += sizeof(struct txbd8) * tx_queue->tx_ring_size;
+		vaddr += sizeof(struct txbd8) * tx_queue->tx_ring_size;
+	}
+
+	/* Start the rx descriptor ring where the tx ring leaves off */
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i];
+		rx_queue->rx_bd_base = vaddr;
+		rx_queue->rx_bd_dma_base = addr;
+		rx_queue->dev = ndev;
+		addr  += sizeof(struct rxbd8) * RX_RING_SIZE;
+		vaddr += sizeof(struct rxbd8) * RX_RING_SIZE;
+	}
+
+	/* Setup the skbuff rings */
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_queue = priv->tx_queue[i];
+		tx_queue->tx_skbuff =
+			kmalloc_array(tx_queue->tx_ring_size,
+				      sizeof(*tx_queue->tx_skbuff),
+				      GFP_KERNEL);
+		if (!tx_queue->tx_skbuff)
+			goto cleanup;
+
+		for (k = 0; k < tx_queue->tx_ring_size; k++)
+			tx_queue->tx_skbuff[k] = NULL;
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i];
+
+		for (j = 0; j < RX_RING_SIZE; j++) {
+			memset(&rx_queue->rx_pktbuff[j], 0, sizeof(rx_queue->rx_pktbuff[0]));
+		}
+		rx_queue->rx_freepkt = rx_queue->rx_currpkt;
+	}
+
+	if (gfarw_init_bds(ndev))
+		goto cleanup;
+
+	return 0;
+
+cleanup:
+	free_skb_resources(priv);
+	return -ENOMEM;
+}
+
+static void gfarw_init_tx_rx_base(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 __iomem *baddr;
+	int i;
+
+	baddr = &regs->tbase0;
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		gfarw_write(baddr, priv->tx_queue[i]->tx_bd_dma_base);
+		baddr += 2;
+	}
+
+	baddr = &regs->rbase0;
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		gfarw_write(baddr, priv->rx_queue[i]->rx_bd_dma_base);
+		baddr += 2;
+	}
+}
+
+static void gfarw_init_rqprm(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 __iomem *baddr;
+	int i;
+
+	baddr = &regs->rqprm0;
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		gfarw_write(baddr, RX_RING_SIZE | (DEFAULT_RX_LFC_THR << FBTHR_SHIFT));
+		baddr++;
+	}
+}
+
+static void gfarw_rx_buff_size_config(struct gfarw_private *priv)
+{
+	int frame_size = priv->ndev->mtu + ETH_HLEN + ETH_FCS_LEN;
+
+	/* set this when rx hw offload (TOE) functions are being used */
+	priv->uses_rxfcb = 0;
+
+	if (priv->ndev->features & (NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_RX))
+		priv->uses_rxfcb = 1;
+
+	if (priv->hwts_rx_en)
+		priv->uses_rxfcb = 1;
+
+	if (priv->uses_rxfcb)
+		frame_size += GMAC_FCB_LEN;
+
+	frame_size += priv->padding;
+
+	frame_size = (frame_size & ~(INCREMENTAL_BUFFER_SIZE - 1)) +
+		     INCREMENTAL_BUFFER_SIZE;
+
+	priv->rx_buffer_size = frame_size;
+}
+
+static void gfarw_mac_rx_config(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 rctrl = 0;
+
+	if (priv->rx_filer_enable) {
+		rctrl |= RCTRL_FILREN;
+		/* Program the RIR0 reg with the required distribution */
+		if (priv->poll_mode == GFAR_SQ_POLLING)
+			gfarw_write(&regs->rir0, DEFAULT_2RXQ_RIR0);
+		else /* GFAR_MQ_POLLING */
+			gfarw_write(&regs->rir0, DEFAULT_8RXQ_RIR0);
+	}
+
+	/* Restore PROMISC mode */
+	if (priv->ndev->flags & IFF_PROMISC)
+		rctrl |= RCTRL_PROM;
+
+	if (priv->ndev->features & NETIF_F_RXCSUM)
+		rctrl |= RCTRL_CHECKSUMMING;
+
+	if (priv->extended_hash)
+		rctrl |= RCTRL_EXTHASH | RCTRL_EMEN;
+
+	if (priv->padding) {
+		rctrl &= ~RCTRL_PAL_MASK;
+		rctrl |= RCTRL_PADDING(priv->padding);
+	}
+
+	/* Enable HW time stamping if requested from user space */
+	if (priv->hwts_rx_en)
+		rctrl |= RCTRL_PRSDEP_INIT | RCTRL_TS_ENABLE;
+
+	if (priv->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)
+		rctrl |= RCTRL_VLEX | RCTRL_PRSDEP_INIT;
+
+	/* Clear the LFC bit */
+	gfarw_write(&regs->rctrl, rctrl);
+	/* Init flow control threshold values */
+	gfarw_init_rqprm(priv);
+	gfarw_write(&regs->ptv, DEFAULT_LFC_PTVVAL);
+	rctrl |= RCTRL_LFC;
+
+	/* Init rctrl based on our settings */
+	gfarw_write(&regs->rctrl, rctrl);
+}
+
+static void gfarw_mac_tx_config(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tctrl = 0;
+
+	if (priv->ndev->features & NETIF_F_IP_CSUM)
+		tctrl |= TCTRL_INIT_CSUM;
+
+	if (priv->prio_sched_en)
+		tctrl |= TCTRL_TXSCHED_PRIO;
+	else {
+		tctrl |= TCTRL_TXSCHED_WRRS;
+		gfarw_write(&regs->tr03wt, DEFAULT_WRRS_WEIGHT);
+		gfarw_write(&regs->tr47wt, DEFAULT_WRRS_WEIGHT);
+	}
+
+	if (priv->ndev->features & NETIF_F_HW_VLAN_CTAG_TX)
+		tctrl |= TCTRL_VLINS;
+
+	gfarw_write(&regs->tctrl, tctrl);
+}
+
+static void gfarw_configure_coalescing(struct gfarw_private *priv,
+			       unsigned long tx_mask, unsigned long rx_mask)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 __iomem *baddr;
+
+	if (priv->mode == MQ_MG_MODE) {
+		int i = 0;
+
+		baddr = &regs->txic0;
+		for_each_set_bit(i, &tx_mask, priv->num_tx_queues) {
+			gfarw_write(baddr + i, 0);
+			if (likely(priv->tx_queue[i]->txcoalescing))
+				gfarw_write(baddr + i, priv->tx_queue[i]->txic);
+		}
+
+		baddr = &regs->rxic0;
+		for_each_set_bit(i, &rx_mask, priv->num_rx_queues) {
+			gfarw_write(baddr + i, 0);
+			if (likely(priv->rx_queue[i]->rxcoalescing))
+				gfarw_write(baddr + i, priv->rx_queue[i]->rxic);
+		}
+	} else {
+		/* Backward compatible case -- even if we enable
+		 * multiple queues, there's only single reg to program
+		 */
+		gfarw_write(&regs->txic, 0);
+		if (likely(priv->tx_queue[0]->txcoalescing))
+			gfarw_write(&regs->txic, priv->tx_queue[0]->txic);
+
+		gfarw_write(&regs->rxic, 0);
+		if (unlikely(priv->rx_queue[0]->rxcoalescing))
+			gfarw_write(&regs->rxic, priv->rx_queue[0]->rxic);
+	}
+}
+
+void gfarw_configure_coalescing_all(struct gfarw_private *priv)
+{
+	gfarw_configure_coalescing(priv, 0xFF, 0xFF);
+}
+
+static struct net_device_stats *gfarw_get_stats(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	unsigned long rx_packets = 0, rx_bytes = 0, rx_dropped = 0;
+	unsigned long tx_packets = 0, tx_bytes = 0;
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_packets += priv->rx_queue[i]->stats.rx_packets;
+		rx_bytes   += priv->rx_queue[i]->stats.rx_bytes;
+		rx_dropped += priv->rx_queue[i]->stats.rx_dropped;
+	}
+
+	dev->stats.rx_packets = rx_packets;
+	dev->stats.rx_bytes   = rx_bytes;
+	dev->stats.rx_dropped = rx_dropped;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_bytes += priv->tx_queue[i]->stats.tx_bytes;
+		tx_packets += priv->tx_queue[i]->stats.tx_packets;
+	}
+
+	dev->stats.tx_bytes   = tx_bytes;
+	dev->stats.tx_packets = tx_packets;
+
+	return &dev->stats;
+}
+
+int gfarw_set_features(struct net_device *dev, netdev_features_t features)
+{
+	netdev_features_t changed = dev->features ^ features;
+	struct gfarw_private *priv = netdev_priv(dev);
+	int err = 0;
+
+	if (!(changed & (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
+			 NETIF_F_RXCSUM)))
+		return 0;
+
+	while (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))
+		cpu_relax();
+
+	dev->features = features;
+
+	if (dev->flags & IFF_UP) {
+		/* Now we take down the rings to rebuild them */
+		stop_gfarw(dev);
+		err = startup_gfarw(dev);
+	} else {
+		gfarw_mac_reset(priv);
+	}
+
+	clear_bit_unlock(GFAR_RESETTING, &priv->state);
+
+	return err;
+}
+
+static int gfarw_set_mac_addr(struct net_device *dev, void *p)
+{
+	eth_mac_addr(dev, p);
+
+	gfarw_set_mac_for_addr(dev, 0, dev->dev_addr);
+
+	return 0;
+}
+
+static const struct net_device_ops gfarw_netdev_ops = {
+	.ndo_open = gfarw_enet_open,
+	.ndo_start_xmit = gfarw_start_xmit,
+	.ndo_stop = gfarw_close,
+	.ndo_change_mtu = gfarw_change_mtu,
+	.ndo_set_features = gfarw_set_features,
+	.ndo_set_rx_mode = gfarw_set_multi,
+	.ndo_tx_timeout = gfarw_timeout,
+	.ndo_do_ioctl = gfarw_ioctl,
+	.ndo_get_stats = gfarw_get_stats,
+	.ndo_set_mac_address = gfarw_set_mac_addr,
+	.ndo_validate_addr = eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = gfarw_netpoll,
+#endif
+};
+
+static void gfarw_ints_disable(struct gfarw_private *priv)
+{
+	int i;
+	for (i = 0; i < priv->num_grps; i++) {
+		struct gfarw __iomem *regs = priv->gfarwgrp[i].regs;
+		/* Clear IEVENT */
+		gfarw_write(&regs->ievent, IEVENT_INIT_CLEAR);
+
+		/* Initialize IMASK */
+		gfarw_write(&regs->imask, IMASK_INIT_CLEAR);
+	}
+}
+
+static void gfarw_ints_enable(struct gfarw_private *priv)
+{
+	int i;
+	for (i = 0; i < priv->num_grps; i++) {
+		struct gfarw __iomem *regs = priv->gfarwgrp[i].regs;
+		/* Unmask the interrupts we look for */
+		gfarw_write(&regs->imask, IMASK_DEFAULT);
+	}
+}
+
+static int gfarw_alloc_tx_queues(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i] = kzalloc(sizeof(struct gfarw_priv_tx_q),
+					    GFP_KERNEL);
+		if (!priv->tx_queue[i])
+			return -ENOMEM;
+
+		priv->tx_queue[i]->tx_skbuff = NULL;
+		priv->tx_queue[i]->qindex = i;
+		priv->tx_queue[i]->dev = priv->ndev;
+		spin_lock_init(&(priv->tx_queue[i]->txlock));
+	}
+	return 0;
+}
+
+static int gfarw_alloc_rx_queues(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		priv->rx_queue[i] = kzalloc(sizeof(struct gfarw_priv_rx_q), GFP_KERNEL);
+		if (!priv->rx_queue[i])
+			return -ENOMEM;
+
+		priv->rx_queue[i]->rx_pktbuff = NULL;
+		priv->rx_queue[i]->qindex = i;
+		priv->rx_queue[i]->dev = priv->ndev;
+
+		priv->rx_queue[i]->rx_pktbuff = kmalloc_array(RX_RING_SIZE, sizeof(priv->rx_queue[i]->rx_pktbuff[0]),
+		                                              GFP_KERNEL);
+		if (!priv->rx_queue[i]->rx_pktbuff) {
+			printk(KERN_ERR "%s:%d Failed to allocate %d bytes!\n", __FILE__, __LINE__,
+			       RX_RING_SIZE * sizeof(priv->rx_queue[i]->rx_pktbuff[0]));
+			return -ENOMEM;
+		}
+
+		priv->rx_queue[i]->rx_currpkt = 0;
+		priv->rx_queue[i]->rx_freepkt = 0;
+	}
+	return 0;
+}
+
+static void gfarw_free_tx_queues(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++)
+		kfree(priv->tx_queue[i]);
+}
+
+static void gfarw_free_rx_queues(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		kfree(priv->rx_queue[i]->rx_pktbuff);
+		priv->rx_queue[i]->rx_pktbuff = NULL;
+
+		kfree(priv->rx_queue[i]);
+		kfree(priv->rx_queue[i]);
+		priv->rx_queue[i] = NULL;
+	}
+}
+
+static void unmap_group_regs(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < MAXGROUPS; i++)
+		if (priv->gfarwgrp[i].regs)
+			iounmap(priv->gfarwgrp[i].regs);
+}
+
+static void free_gfarw_dev(struct gfarw_private *priv)
+{
+	int i, j;
+
+	for (i = 0; i < priv->num_grps; i++)
+		for (j = 0; j < GFAR_NUM_IRQS; j++) {
+			kfree(priv->gfarwgrp[i].irqinfo[j]);
+			priv->gfarwgrp[i].irqinfo[j] = NULL;
+		}
+
+	free_netdev(priv->ndev);
+}
+
+static void disable_napi(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_grps; i++) {
+		napi_disable(&priv->gfarwgrp[i].napi_rx);
+		napi_disable(&priv->gfarwgrp[i].napi_tx);
+	}
+}
+
+static void enable_napi(struct gfarw_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_grps; i++) {
+		napi_enable(&priv->gfarwgrp[i].napi_rx);
+		napi_enable(&priv->gfarwgrp[i].napi_tx);
+	}
+}
+
+static int gfarw_parse_group(struct device_node *np,
+			    struct gfarw_private *priv, const char *model)
+{
+	struct gfarw_priv_grp *grp = &priv->gfarwgrp[priv->num_grps];
+	int i;
+
+	for (i = 0; i < GFAR_NUM_IRQS; i++) {
+		grp->irqinfo[i] = kzalloc(sizeof(struct gfarw_irqinfo),
+					  GFP_KERNEL);
+		if (!grp->irqinfo[i])
+			return -ENOMEM;
+	}
+
+	grp->regs = of_iomap(np, 0);
+	if (!grp->regs)
+		return -ENOMEM;
+
+	gfarw_irq(grp, TX)->irq = irq_of_parse_and_map(np, 0);
+
+	/* If we aren't the FEC we have multiple interrupts */
+	if (model && strcasecmp(model, "FEC")) {
+		gfarw_irq(grp, RX)->irq = irq_of_parse_and_map(np, 1);
+		gfarw_irq(grp, ER)->irq = irq_of_parse_and_map(np, 2);
+		if (gfarw_irq(grp, TX)->irq == NO_IRQ ||
+		    gfarw_irq(grp, RX)->irq == NO_IRQ ||
+		    gfarw_irq(grp, ER)->irq == NO_IRQ)
+			return -EINVAL;
+	}
+
+	grp->priv = priv;
+	spin_lock_init(&grp->grplock);
+	if (priv->mode == MQ_MG_MODE) {
+		u32 rxq_mask, txq_mask;
+		int ret;
+
+		grp->rx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
+		grp->tx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
+
+		ret = of_property_read_u32(np, "fsl,rx-bit-map", &rxq_mask);
+		if (!ret) {
+			grp->rx_bit_map = rxq_mask ?
+			rxq_mask : (DEFAULT_MAPPING >> priv->num_grps);
+		}
+
+		ret = of_property_read_u32(np, "fsl,tx-bit-map", &txq_mask);
+		if (!ret) {
+			grp->tx_bit_map = txq_mask ?
+			txq_mask : (DEFAULT_MAPPING >> priv->num_grps);
+		}
+
+		if (priv->poll_mode == GFAR_SQ_POLLING) {
+			/* One Q per interrupt group: Q0 to G0, Q1 to G1 */
+			grp->rx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
+			grp->tx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
+		}
+	} else {
+		grp->rx_bit_map = 0xFF;
+		grp->tx_bit_map = 0xFF;
+	}
+
+	/* bit_map's MSB is q0 (from q0 to q7) but, for_each_set_bit parses
+	 * right to left, so we need to revert the 8 bits to get the q index
+	 */
+	grp->rx_bit_map = bitrev8(grp->rx_bit_map);
+	grp->tx_bit_map = bitrev8(grp->tx_bit_map);
+
+	/* Calculate RSTAT, TSTAT, RQUEUE and TQUEUE values,
+	 * also assign queues to groups
+	 */
+	for_each_set_bit(i, &grp->rx_bit_map, priv->num_rx_queues) {
+		if (!grp->rx_queue)
+			grp->rx_queue = priv->rx_queue[i];
+		grp->num_rx_queues++;
+		grp->rstat |= (RSTAT_CLEAR_RHALT >> i);
+		priv->rqueue |= ((RQUEUE_EN0 | RQUEUE_EX0) >> i);
+		priv->rx_queue[i]->grp = grp;
+	}
+
+	for_each_set_bit(i, &grp->tx_bit_map, priv->num_tx_queues) {
+		if (!grp->tx_queue)
+			grp->tx_queue = priv->tx_queue[i];
+		grp->num_tx_queues++;
+		grp->tstat |= (TSTAT_CLEAR_THALT >> i);
+		priv->tqueue |= (TQUEUE_EN0 >> i);
+		priv->tx_queue[i]->grp = grp;
+	}
+
+	priv->num_grps++;
+
+	return 0;
+}
+
+static int gfarw_of_group_count(struct device_node *np)
+{
+	struct device_node *child;
+	int num = 0;
+
+	for_each_available_child_of_node(np, child)
+		if (!of_node_cmp(child->name, "queue-group"))
+			num++;
+
+	return num;
+}
+
+static int gfarw_of_init(struct platform_device *ofdev, struct net_device **pdev)
+{
+	const char *model;
+	const char *ctype;
+	const void *mac_addr;
+	int err = 0, i;
+	struct net_device *dev = NULL;
+	struct gfarw_private *priv = NULL;
+	struct device_node *np = ofdev->dev.of_node;
+	struct device_node *child = NULL;
+	struct property *stash;
+	u32 stash_len = 0;
+	u32 stash_idx = 0;
+	unsigned int num_tx_qs, num_rx_qs;
+	unsigned short mode, poll_mode;
+
+	if (!np)
+		return -ENODEV;
+
+	if (of_device_is_compatible(np, "fsl,etsec2")) {
+		mode = MQ_MG_MODE;
+		poll_mode = GFAR_SQ_POLLING;
+	} else {
+		mode = SQ_SG_MODE;
+		poll_mode = GFAR_SQ_POLLING;
+	}
+
+	if (mode == SQ_SG_MODE) {
+		num_tx_qs = 1;
+		num_rx_qs = 1;
+	} else { /* MQ_MG_MODE */
+		/* get the actual number of supported groups */
+		unsigned int num_grps = gfarw_of_group_count(np);
+
+		if (num_grps == 0 || num_grps > MAXGROUPS) {
+			dev_err(&ofdev->dev, "Invalid # of int groups(%d)\n",
+				num_grps);
+			pr_err("Cannot do alloc_etherdev, aborting\n");
+			return -EINVAL;
+		}
+
+		if (poll_mode == GFAR_SQ_POLLING) {
+			num_tx_qs = num_grps; /* one txq per int group */
+			num_rx_qs = num_grps; /* one rxq per int group */
+		} else { /* GFAR_MQ_POLLING */
+			u32 tx_queues, rx_queues;
+			int ret;
+
+			/* parse the num of HW tx and rx queues */
+			ret = of_property_read_u32(np, "fsl,num_tx_queues",
+						   &tx_queues);
+			num_tx_qs = ret ? 1 : tx_queues;
+
+			ret = of_property_read_u32(np, "fsl,num_rx_queues",
+						   &rx_queues);
+			num_rx_qs = ret ? 1 : rx_queues;
+		}
+	}
+
+	if (num_tx_qs > MAX_TX_QS) {
+		pr_err("num_tx_qs(=%d) greater than MAX_TX_QS(=%d)\n",
+		       num_tx_qs, MAX_TX_QS);
+		pr_err("Cannot do alloc_etherdev, aborting\n");
+		return -EINVAL;
+	}
+
+	if (num_rx_qs > MAX_RX_QS) {
+		pr_err("num_rx_qs(=%d) greater than MAX_RX_QS(=%d)\n",
+		       num_rx_qs, MAX_RX_QS);
+		pr_err("Cannot do alloc_etherdev, aborting\n");
+		return -EINVAL;
+	}
+
+	*pdev = alloc_etherdev_mq(sizeof(*priv), num_tx_qs);
+	dev = *pdev;
+	if (NULL == dev)
+		return -ENOMEM;
+
+	priv = netdev_priv(dev);
+	priv->ndev = dev;
+
+	priv->mode = mode;
+	priv->poll_mode = poll_mode;
+
+	priv->num_tx_queues = num_tx_qs;
+	netif_set_real_num_rx_queues(dev, num_rx_qs);
+	priv->num_rx_queues = num_rx_qs;
+
+	err = gfarw_alloc_tx_queues(priv);
+	if (err)
+		goto tx_alloc_failed;
+
+	err = gfarw_alloc_rx_queues(priv);
+	if (err)
+		goto rx_alloc_failed;
+
+	err = of_property_read_string(np, "model", &model);
+	if (err) {
+		pr_err("Device model property missing, aborting\n");
+		goto rx_alloc_failed;
+	}
+
+	/* Init Rx queue filer rule set linked list */
+	INIT_LIST_HEAD(&priv->rx_list.list);
+	priv->rx_list.count = 0;
+	mutex_init(&priv->rx_queue_access);
+
+	for (i = 0; i < MAXGROUPS; i++)
+		priv->gfarwgrp[i].regs = NULL;
+
+	/* Parse and initialize group specific information */
+	if (priv->mode == MQ_MG_MODE) {
+		for_each_available_child_of_node(np, child) {
+			if (of_node_cmp(child->name, "queue-group"))
+				continue;
+
+			err = gfarw_parse_group(child, priv, model);
+			if (err)
+				goto err_grp_init;
+		}
+	} else { /* SQ_SG_MODE */
+		err = gfarw_parse_group(np, priv, model);
+		if (err)
+			goto err_grp_init;
+	}
+
+	stash = of_find_property(np, "bd-stash", NULL);
+
+	if (stash) {
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_BD_STASHING;
+		priv->bd_stash_en = 1;
+	}
+
+	err = of_property_read_u32(np, "rx-stash-len", &stash_len);
+
+	if (err == 0)
+		priv->rx_stash_size = stash_len;
+
+	err = of_property_read_u32(np, "rx-stash-idx", &stash_idx);
+
+	if (err == 0)
+		priv->rx_stash_index = stash_idx;
+
+	if (stash_len || stash_idx)
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_BUF_STASHING;
+
+	mac_addr = of_get_mac_address(np);
+
+	if (mac_addr)
+		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
+
+	if (model && !strcasecmp(model, "TSEC"))
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_GIGABIT |
+				     FSL_GIANFAR_DEV_HAS_COALESCE |
+				     FSL_GIANFAR_DEV_HAS_RMON |
+				     FSL_GIANFAR_DEV_HAS_MULTI_INTR;
+
+	if (model && !strcasecmp(model, "eTSEC"))
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_GIGABIT |
+				     FSL_GIANFAR_DEV_HAS_COALESCE |
+				     FSL_GIANFAR_DEV_HAS_RMON |
+				     FSL_GIANFAR_DEV_HAS_MULTI_INTR |
+				     FSL_GIANFAR_DEV_HAS_CSUM |
+				     FSL_GIANFAR_DEV_HAS_VLAN |
+				     FSL_GIANFAR_DEV_HAS_MAGIC_PACKET |
+				     FSL_GIANFAR_DEV_HAS_EXTENDED_HASH |
+				     FSL_GIANFAR_DEV_HAS_TIMER;
+
+	err = of_property_read_string(np, "phy-connection-type", &ctype);
+
+	/* We only care about rgmii-id.  The rest are autodetected */
+	if (err == 0 && !strcmp(ctype, "rgmii-id"))
+		priv->interface = PHY_INTERFACE_MODE_RGMII_ID;
+	else
+		priv->interface = PHY_INTERFACE_MODE_MII;
+
+	if (of_find_property(np, "fsl,magic-packet", NULL))
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
+
+	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
+
+	/* In the case of a fixed PHY, the DT node associated
+	 * to the PHY is the Ethernet MAC DT node.
+	 */
+	if (!priv->phy_node && of_phy_is_fixed_link(np)) {
+		err = of_phy_register_fixed_link(np);
+		if (err)
+			goto err_grp_init;
+
+		priv->phy_node = of_node_get(np);
+	}
+
+	/* Find the TBI PHY.  If it's not there, we don't support SGMII */
+	priv->tbi_node = of_parse_phandle(np, "tbi-handle", 0);
+
+	return 0;
+
+err_grp_init:
+	unmap_group_regs(priv);
+rx_alloc_failed:
+	gfarw_free_rx_queues(priv);
+tx_alloc_failed:
+	gfarw_free_tx_queues(priv);
+	free_gfarw_dev(priv);
+	return err;
+}
+
+static int gfarw_hwtstamp_set(struct net_device *netdev, struct ifreq *ifr)
+{
+	struct hwtstamp_config config;
+	struct gfarw_private *priv = netdev_priv(netdev);
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (config.flags)
+		return -EINVAL;
+
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		priv->hwts_tx_en = 0;
+		break;
+	case HWTSTAMP_TX_ON:
+		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
+			return -ERANGE;
+		priv->hwts_tx_en = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		if (priv->hwts_rx_en) {
+			priv->hwts_rx_en = 0;
+			reset_gfarw(netdev);
+		}
+		break;
+	default:
+		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
+			return -ERANGE;
+		if (!priv->hwts_rx_en) {
+			priv->hwts_rx_en = 1;
+			reset_gfarw(netdev);
+		}
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		break;
+	}
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
+}
+
+static int gfarw_hwtstamp_get(struct net_device *netdev, struct ifreq *ifr)
+{
+	struct hwtstamp_config config;
+	struct gfarw_private *priv = netdev_priv(netdev);
+
+	config.flags = 0;
+	config.tx_type = priv->hwts_tx_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;
+	config.rx_filter = (priv->hwts_rx_en ?
+			    HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE);
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
+}
+
+static int gfarw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (cmd == SIOCSHWTSTAMP)
+		return gfarw_hwtstamp_set(dev, rq);
+	if (cmd == SIOCGHWTSTAMP)
+		return gfarw_hwtstamp_get(dev, rq);
+
+	if (!priv->phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(priv->phydev, rq, cmd);
+}
+
+static u32 cluster_entry_per_class(struct gfarw_private *priv, u32 rqfar,
+				   u32 class)
+{
+	u32 rqfpr = FPR_FILER_MASK;
+	u32 rqfcr = 0x0;
+
+	rqfar--;
+	rqfcr = RQFCR_CLE | RQFCR_PID_MASK | RQFCR_CMP_EXACT;
+	priv->ftp_rqfpr[rqfar] = rqfpr;
+	priv->ftp_rqfcr[rqfar] = rqfcr;
+	gfarw_write_filer(priv, rqfar, rqfcr, rqfpr);
+
+	rqfar--;
+	rqfcr = RQFCR_CMP_NOMATCH;
+	priv->ftp_rqfpr[rqfar] = rqfpr;
+	priv->ftp_rqfcr[rqfar] = rqfcr;
+	gfarw_write_filer(priv, rqfar, rqfcr, rqfpr);
+
+	rqfar--;
+	rqfcr = RQFCR_CMP_EXACT | RQFCR_PID_PARSE | RQFCR_CLE | RQFCR_AND;
+	rqfpr = class;
+	priv->ftp_rqfcr[rqfar] = rqfcr;
+	priv->ftp_rqfpr[rqfar] = rqfpr;
+	gfarw_write_filer(priv, rqfar, rqfcr, rqfpr);
+
+	rqfar--;
+	rqfcr = RQFCR_CMP_EXACT | RQFCR_PID_MASK | RQFCR_AND;
+	rqfpr = class;
+	priv->ftp_rqfcr[rqfar] = rqfcr;
+	priv->ftp_rqfpr[rqfar] = rqfpr;
+	gfarw_write_filer(priv, rqfar, rqfcr, rqfpr);
+
+	return rqfar;
+}
+
+static void gfarw_init_filer_table(struct gfarw_private *priv)
+{
+	int i = 0x0;
+	u32 rqfar = MAX_FILER_IDX;
+	u32 rqfcr = 0x0;
+	u32 rqfpr = FPR_FILER_MASK;
+
+	/* Default rule */
+	rqfcr = RQFCR_CMP_MATCH;
+	priv->ftp_rqfcr[rqfar] = rqfcr;
+	priv->ftp_rqfpr[rqfar] = rqfpr;
+	gfarw_write_filer(priv, rqfar, rqfcr, rqfpr);
+
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV6);
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV6 | RQFPR_UDP);
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV6 | RQFPR_TCP);
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV4);
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV4 | RQFPR_UDP);
+	rqfar = cluster_entry_per_class(priv, rqfar, RQFPR_IPV4 | RQFPR_TCP);
+
+	/* cur_filer_idx indicated the first non-masked rule */
+	priv->cur_filer_idx = rqfar;
+
+	/* Rest are masked rules */
+	rqfcr = RQFCR_CMP_NOMATCH;
+	for (i = 0; i < rqfar; i++) {
+		priv->ftp_rqfcr[i] = rqfcr;
+		priv->ftp_rqfpr[i] = rqfpr;
+		gfarw_write_filer(priv, i, rqfcr, rqfpr);
+	}
+}
+
+#ifdef CONFIG_PPC
+static void __gfarw_detect_errata_83xx(struct gfarw_private *priv)
+{
+	unsigned int pvr = mfspr(SPRN_PVR);
+	unsigned int svr = mfspr(SPRN_SVR);
+	unsigned int mod = (svr >> 16) & 0xfff6; /* w/o E suffix */
+	unsigned int rev = svr & 0xffff;
+
+	/* MPC8313 Rev 2.0 and higher; All MPC837x */
+	if ((pvr == 0x80850010 && mod == 0x80b0 && rev >= 0x0020) ||
+	    (pvr == 0x80861010 && (mod & 0xfff9) == 0x80c0))
+		priv->errata |= GFAR_ERRATA_74;
+
+	/* MPC8313 and MPC837x all rev */
+	if ((pvr == 0x80850010 && mod == 0x80b0) ||
+	    (pvr == 0x80861010 && (mod & 0xfff9) == 0x80c0))
+		priv->errata |= GFAR_ERRATA_76;
+
+	/* MPC8313 Rev < 2.0 */
+	if (pvr == 0x80850010 && mod == 0x80b0 && rev < 0x0020)
+		priv->errata |= GFAR_ERRATA_12;
+}
+
+static void __gfarw_detect_errata_85xx(struct gfarw_private *priv)
+{
+	unsigned int svr = mfspr(SPRN_SVR);
+
+	if ((SVR_SOC_VER(svr) == SVR_8548) && (SVR_REV(svr) == 0x20))
+		priv->errata |= GFAR_ERRATA_12;
+	if (((SVR_SOC_VER(svr) == SVR_P2020) && (SVR_REV(svr) < 0x20)) ||
+	    ((SVR_SOC_VER(svr) == SVR_P2010) && (SVR_REV(svr) < 0x20)))
+		priv->errata |= GFAR_ERRATA_76; /* aka eTSEC 20 */
+}
+#endif
+
+static void gfarw_detect_errata(struct gfarw_private *priv)
+{
+	struct device *dev = &priv->ofdev->dev;
+
+	/* no plans to fix */
+	priv->errata |= GFAR_ERRATA_A002;
+
+#ifdef CONFIG_PPC
+	if (pvr_version_is(PVR_VER_E500V1) || pvr_version_is(PVR_VER_E500V2))
+		__gfarw_detect_errata_85xx(priv);
+	else /* non-mpc85xx parts, i.e. e300 core based */
+		__gfarw_detect_errata_83xx(priv);
+#endif
+
+	if (priv->errata)
+		dev_info(dev, "enabled errata workarounds, flags: 0x%x\n",
+			 priv->errata);
+}
+
+void gfarw_mac_reset(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+
+	/* Reset MAC layer */
+	gfarw_write(&regs->maccfg1, MACCFG1_SOFT_RESET);
+
+	/* We need to delay at least 3 TX clocks */
+	udelay(3);
+
+	/* the soft reset bit is not self-resetting, so we need to
+	 * clear it before resuming normal operation
+	 */
+	gfarw_write(&regs->maccfg1, 0);
+
+	udelay(3);
+
+	/* Compute rx_buff_size based on config flags */
+	gfarw_rx_buff_size_config(priv);
+
+	/* Initialize the max receive frame/buffer lengths */
+	gfarw_write(&regs->maxfrm, priv->rx_buffer_size);
+	gfarw_write(&regs->mrblr, priv->rx_buffer_size);
+
+	/* Initialize the Minimum Frame Length Register */
+	gfarw_write(&regs->minflr, MINFLR_INIT_SETTINGS);
+
+	/* Initialize MACCFG2. */
+	tempval = MACCFG2_INIT_SETTINGS;
+
+	/* If the mtu is larger than the max size for standard
+	 * ethernet frames (ie, a jumbo frame), then set maccfg2
+	 * to allow huge frames, and to check the length
+	 */
+	if (priv->rx_buffer_size > DEFAULT_RX_BUFFER_SIZE ||
+	    gfarw_has_errata(priv, GFAR_ERRATA_74))
+		tempval |= MACCFG2_HUGEFRAME | MACCFG2_LENGTHCHECK;
+
+	gfarw_write(&regs->maccfg2, tempval);
+
+	/* Clear mac addr hash registers */
+	gfarw_write(&regs->igaddr0, 0);
+	gfarw_write(&regs->igaddr1, 0);
+	gfarw_write(&regs->igaddr2, 0);
+	gfarw_write(&regs->igaddr3, 0);
+	gfarw_write(&regs->igaddr4, 0);
+	gfarw_write(&regs->igaddr5, 0);
+	gfarw_write(&regs->igaddr6, 0);
+	gfarw_write(&regs->igaddr7, 0);
+
+	gfarw_write(&regs->gaddr0, 0);
+	gfarw_write(&regs->gaddr1, 0);
+	gfarw_write(&regs->gaddr2, 0);
+	gfarw_write(&regs->gaddr3, 0);
+	gfarw_write(&regs->gaddr4, 0);
+	gfarw_write(&regs->gaddr5, 0);
+	gfarw_write(&regs->gaddr6, 0);
+	gfarw_write(&regs->gaddr7, 0);
+
+	if (priv->extended_hash)
+		gfarw_clear_exact_match(priv->ndev);
+
+	gfarw_mac_rx_config(priv);
+
+	gfarw_mac_tx_config(priv);
+
+	gfarw_set_mac_address(priv->ndev);
+
+	gfarw_set_multi(priv->ndev);
+
+	/* clear ievent and imask before configuring coalescing */
+	gfarw_ints_disable(priv);
+
+	/* Configure the coalescing support */
+	gfarw_configure_coalescing_all(priv);
+}
+
+static void gfarw_hw_init(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 attrs;
+
+	/* Stop the DMA engine now, in case it was running before
+	 * (The firmware could have used it, and left it running).
+	 */
+	gfarw_halt(priv);
+
+	gfarw_mac_reset(priv);
+
+	/* Zero out the rmon mib registers if it has them */
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_RMON) {
+		memset_io(&(regs->rmon), 0, sizeof(struct rmon_mib));
+
+		/* Mask off the CAM interrupts */
+		gfarw_write(&regs->rmon.cam1, 0xffffffff);
+		gfarw_write(&regs->rmon.cam2, 0xffffffff);
+	}
+
+	/* Initialize ECNTRL */
+	gfarw_write(&regs->ecntrl, ECNTRL_INIT_SETTINGS);
+
+	/* Set the extraction length and index */
+	attrs = ATTRELI_EL(priv->rx_stash_size) |
+		ATTRELI_EI(priv->rx_stash_index);
+
+	gfarw_write(&regs->attreli, attrs);
+
+	/* Start with defaults, and add stashing
+	 * depending on driver parameters
+	 */
+	attrs = ATTR_INIT_SETTINGS;
+
+	if (priv->bd_stash_en)
+		attrs |= ATTR_BDSTASH;
+
+	if (priv->rx_stash_size != 0)
+		attrs |= ATTR_BUFSTASH;
+
+	gfarw_write(&regs->attr, attrs);
+
+	/* FIFO configs */
+	gfarw_write(&regs->fifo_tx_thr, DEFAULT_FIFO_TX_THR);
+	gfarw_write(&regs->fifo_tx_starve, DEFAULT_FIFO_TX_STARVE);
+	gfarw_write(&regs->fifo_tx_starve_shutoff, DEFAULT_FIFO_TX_STARVE_OFF);
+
+	/* Program the interrupt steering regs, only for MG devices */
+	if (priv->num_grps > 1)
+		gfarw_write_isrg(priv);
+}
+
+static void gfarw_init_addr_hash_table(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_EXTENDED_HASH) {
+		priv->extended_hash = 1;
+		priv->hash_width = 9;
+
+		priv->hash_regs[0] = &regs->igaddr0;
+		priv->hash_regs[1] = &regs->igaddr1;
+		priv->hash_regs[2] = &regs->igaddr2;
+		priv->hash_regs[3] = &regs->igaddr3;
+		priv->hash_regs[4] = &regs->igaddr4;
+		priv->hash_regs[5] = &regs->igaddr5;
+		priv->hash_regs[6] = &regs->igaddr6;
+		priv->hash_regs[7] = &regs->igaddr7;
+		priv->hash_regs[8] = &regs->gaddr0;
+		priv->hash_regs[9] = &regs->gaddr1;
+		priv->hash_regs[10] = &regs->gaddr2;
+		priv->hash_regs[11] = &regs->gaddr3;
+		priv->hash_regs[12] = &regs->gaddr4;
+		priv->hash_regs[13] = &regs->gaddr5;
+		priv->hash_regs[14] = &regs->gaddr6;
+		priv->hash_regs[15] = &regs->gaddr7;
+
+	} else {
+		priv->extended_hash = 0;
+		priv->hash_width = 8;
+
+		priv->hash_regs[0] = &regs->gaddr0;
+		priv->hash_regs[1] = &regs->gaddr1;
+		priv->hash_regs[2] = &regs->gaddr2;
+		priv->hash_regs[3] = &regs->gaddr3;
+		priv->hash_regs[4] = &regs->gaddr4;
+		priv->hash_regs[5] = &regs->gaddr5;
+		priv->hash_regs[6] = &regs->gaddr6;
+		priv->hash_regs[7] = &regs->gaddr7;
+	}
+}
+
+
+
+static int work_buffer_open(struct inode *node, struct file *file) {
+	struct gfarw_private *priv = PDE_DATA(node);
+
+	file->private_data = priv;
+
+	return 0;
+}
+static ssize_t work_buffer_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	return 0;
+}
+static int work_buffer_close(struct inode *inode, struct file *file) {
+	return 0;
+}
+
+/* keep track of how many times it is mmapped */
+static void work_buffer_mmap_open(struct vm_area_struct *vma) {
+}
+
+static void work_buffer_mmap_close(struct vm_area_struct *vma) {
+}
+
+/* called to map area initially */
+static int work_buffer_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf) {
+	struct gfarw_private *priv = vma->vm_private_data;
+	struct gfarw_priv_rx_q *rx_queue;
+	pgoff_t pgoff = vmf->pgoff;
+	struct page *page;
+
+	if (priv->num_rx_queues < 1) {
+		printk(KERN_ERR "%s WORK: Rx-queue missing!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+	if (priv->num_rx_queues > 1) {
+		printk(KERN_ERR "%s WORK: Invalid configuration with more than one rx-queue!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+
+	rx_queue = priv->rx_queue[0];
+
+	if ((pgoff << PAGE_SHIFT) > (RX_RING_SIZE * sizeof(rx_queue->rx_pktbuff[0]))) {
+		printk(KERN_ERR "%s WORK: Given offset extends mapped area!\n", __func__);
+		return VM_FAULT_OOM;
+	}
+
+	page = virt_to_page((char*)(rx_queue->rx_pktbuff) + (pgoff << PAGE_SHIFT));
+	if (!page) {
+		printk(KERN_ERR "%s: Failed to map offset 0x%lx!\n",
+		       __func__, (pgoff << PAGE_SHIFT));
+		return VM_FAULT_SIGBUS;
+	}
+
+	/* increment the reference count of this page */
+	get_page(page);
+	vmf->page = page;
+
+	return 0;
+}
+
+static struct vm_operations_struct work_buffer_mmap_vm_ops = {
+	.open  = work_buffer_mmap_open,
+	.close = work_buffer_mmap_close,
+	.fault = work_buffer_mmap_fault,
+};
+
+static int work_buffer_mmap(struct file *f, struct vm_area_struct *vma) {
+	unsigned long size = vma->vm_end - vma->vm_start;
+	struct gfarw_private *priv = f->private_data;
+
+	if (size != (RX_RING_SIZE * sizeof(priv->rx_queue[0]->rx_pktbuff[0]))) {
+		printk(KERN_ERR "Memory map does not cover buffer of %d bytes!\n",
+		       RX_RING_SIZE * sizeof(priv->rx_queue[0]->rx_pktbuff[0]));
+		return -EINVAL;
+	}
+
+	vma->vm_ops = &work_buffer_mmap_vm_ops;
+	vma->vm_private_data = priv;
+	work_buffer_mmap_open(vma);
+
+	return 0;
+}
+
+static const struct file_operations work_buffer_fops = {
+	.open = &work_buffer_open,
+	.read = &work_buffer_read,
+	.release = &work_buffer_close,
+	.mmap = &work_buffer_mmap,
+};
+
+
+
+static int work_ipv4_open(struct inode *node, struct file *file) {
+	file->private_data = kmalloc(sizeof(int), GFP_KERNEL);
+	*((int*)file->private_data) = 0;
+	return 0;
+}
+static ssize_t work_ipv4_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfarw_private *priv = PDE_DATA(file_inode(file));
+	__kernel_size_t strsize;
+
+	if (*((int*)file->private_data) != 0)
+		return 0;
+
+	snprintf(buf, size-1, "%d.%d.%d.%d", (priv->f_ipv4 >> 24), (priv->f_ipv4 >> 16) & 0xFF,
+	         (priv->f_ipv4 >> 8) & 0xFF, priv->f_ipv4 & 0xFF);
+	buf[size-1] = '\0';
+
+	strsize = strlen(buf);
+	*((int*)file->private_data) = strsize;
+	return strsize;
+}
+static ssize_t work_ipv4_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfarw_private *priv = PDE_DATA(file_inode(file));
+	char tmp = 0xFA;
+	int ip[4];
+
+	if (size >= 7 && sscanf(buf, "%d.%d.%d.%d%c", &ip[0], &ip[1], &ip[2], &ip[3], &tmp) >= 4) {
+		priv->f_ipv4 = 0;
+		priv->f_ipv4 |= (ip[0] & 0xFF) << 24;
+		priv->f_ipv4 |= (ip[1] & 0xFF) << 16;
+		priv->f_ipv4 |= (ip[2] & 0xFF) << 8;
+		priv->f_ipv4 |= (ip[3] & 0xFF);
+
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Wrong IP-Format! Expecting XXX.XXX.XXX.XXX\n");
+		return -EINVAL;
+	}
+}
+static int work_ipv4_close(struct inode *inode, struct file *file) {
+	if (file->private_data) {
+		kfree(file->private_data);
+		file->private_data = NULL;
+	}
+	return 0;
+}
+
+static const struct file_operations work_ipv4_fops = {
+	.open = &work_ipv4_open,
+	.read = &work_ipv4_read,
+	.write = &work_ipv4_write,
+	.release = &work_ipv4_close,
+};
+
+
+
+static int work_mac_open(struct inode *node, struct file *file) {
+	file->private_data = kmalloc(sizeof(int), GFP_KERNEL);
+	*((int*)file->private_data) = 0;
+	return 0;
+}
+static ssize_t work_mac_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	struct gfarw_private *priv = PDE_DATA(file_inode(file));
+	__kernel_size_t strsize;
+
+	if (*((int*)file->private_data) != 0)
+		return 0;
+
+	snprintf(buf, size-1, "%02x:%02x:%02x:%02x:%02x:%02x",
+	         priv->f_mac[0], priv->f_mac[1], priv->f_mac[2],
+	         priv->f_mac[3], priv->f_mac[4], priv->f_mac[5]);
+	buf[size-1] = '\0';
+
+	strsize = strlen(buf);
+	*((int*)file->private_data) = strsize;
+	return strsize;
+}
+static ssize_t work_mac_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos) {
+	struct gfarw_private *priv = PDE_DATA(file_inode(file));
+	char tmp;
+	int mac[ETH_ALEN], cnt;
+
+	if (sscanf(buf,"%x:%x:%x:%x:%x:%x%c",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5],&tmp)>=6) {
+		for (cnt=0; cnt<ETH_ALEN; cnt++) {
+			priv->f_mac[cnt] = mac[cnt] & 0xFF;
+		}
+
+		if (!is_valid_ether_addr(priv->f_mac)) {
+			printk(KERN_ERR "Invalid MAC-Address!\n");
+			memset(priv->f_mac, 0, sizeof(priv->f_mac));
+			return -EINVAL;
+		}
+		return size;
+	}
+	else {
+		printk(KERN_ERR "Wrong MAC-Format! Expecting XX:XX:XX:XX:XX:XX\n");
+		return -EINVAL;
+	}
+}
+static int work_mac_close(struct inode *inode, struct file *file) {
+	if (file->private_data) {
+		kfree(file->private_data);
+		file->private_data = NULL;
+	}
+	return 0;
+}
+
+static const struct file_operations work_mac_fops = {
+	.open = &work_mac_open,
+	.read = &work_mac_read,
+	.write = &work_mac_write,
+	.release = &work_mac_close,
+};
+
+
+/* Set up the ethernet device structure, private data,
+ * and anything else we need before we start
+ */
+static int gfarw_probe(struct platform_device *ofdev)
+{
+	struct net_device *dev = NULL;
+	struct gfarw_private *priv = NULL;
+	int err = 0, i;
+
+	err = gfarw_of_init(ofdev, &dev);
+
+	if (err)
+		return err;
+
+	priv = netdev_priv(dev);
+	priv->ndev = dev;
+	priv->ofdev = ofdev;
+	priv->dev = &ofdev->dev;
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+
+	INIT_WORK(&priv->reset_task, gfarw_reset_task);
+
+	platform_set_drvdata(ofdev, priv);
+
+	gfarw_detect_errata(priv);
+
+	/* Set the dev->base_addr to the gfarw reg region */
+	dev->base_addr = (unsigned long) priv->gfarwgrp[0].regs;
+
+	/* Fill in the dev structure */
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->mtu = 1500;
+	dev->netdev_ops = &gfarw_netdev_ops;
+	dev->ethtool_ops = &gfar_ethtool_ops;
+
+	/* Register for napi ...We are registering NAPI for each grp */
+	for (i = 0; i < priv->num_grps; i++) {
+		if (priv->poll_mode == GFAR_SQ_POLLING) {
+			netif_napi_add(dev, &priv->gfarwgrp[i].napi_rx,
+				       gfarw_poll_rx_sq, GFAR_DEV_WEIGHT);
+			netif_napi_add(dev, &priv->gfarwgrp[i].napi_tx,
+				       gfarw_poll_tx_sq, 2);
+		} else {
+			netif_napi_add(dev, &priv->gfarwgrp[i].napi_rx,
+				       gfarw_poll_rx, GFAR_DEV_WEIGHT);
+			netif_napi_add(dev, &priv->gfarwgrp[i].napi_tx,
+				       gfarw_poll_tx, 2);
+		}
+	}
+
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_CSUM) {
+		dev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |
+				   NETIF_F_RXCSUM;
+		dev->features |= NETIF_F_IP_CSUM | NETIF_F_SG |
+				 NETIF_F_RXCSUM | NETIF_F_HIGHDMA;
+	}
+
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_VLAN) {
+		dev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX |
+				    NETIF_F_HW_VLAN_CTAG_RX;
+		dev->features |= NETIF_F_HW_VLAN_CTAG_RX;
+	}
+
+	dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+
+	gfarw_init_addr_hash_table(priv);
+
+	/* Insert receive time stamps into padding alignment bytes */
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)
+		priv->padding = 8;
+
+	if (dev->features & NETIF_F_IP_CSUM ||
+	    priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)
+		dev->needed_headroom = GMAC_FCB_LEN;
+
+	priv->rx_buffer_size = DEFAULT_RX_BUFFER_SIZE;
+
+	/* Initializing some of the rx/tx queue level parameters */
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i]->tx_ring_size = DEFAULT_TX_RING_SIZE;
+		priv->tx_queue[i]->num_txbdfree = DEFAULT_TX_RING_SIZE;
+		priv->tx_queue[i]->txcoalescing = DEFAULT_TX_COALESCE;
+		priv->tx_queue[i]->txic = DEFAULT_TXIC;
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		priv->rx_queue[i]->rx_ring_size = RX_RING_SIZE;
+		priv->rx_queue[i]->rxcoalescing = DEFAULT_RX_COALESCE;
+		priv->rx_queue[i]->rxic = DEFAULT_RXIC;
+	}
+
+	/* always enable rx filer */
+	priv->rx_filer_enable = 1;
+	/* Enable most messages by default */
+	priv->msg_enable = (NETIF_MSG_IFUP << 1 ) - 1;
+	/* use pritority h/w tx queue scheduling for single queue devices */
+	if (priv->num_tx_queues == 1)
+		priv->prio_sched_en = 1;
+
+	set_bit(GFAR_DOWN, &priv->state);
+
+	gfarw_hw_init(priv);
+
+	/* Carrier starts down, phylib will bring it up */
+	netif_carrier_off(dev);
+
+	err = register_netdev(dev);
+
+	if (err) {
+		pr_err("%s: Cannot register net device, aborting\n", dev->name);
+		goto register_fail;
+	}
+
+	device_set_wakeup_capable(&dev->dev, priv->device_flags &
+				  FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+
+	/* fill out IRQ number and name fields */
+	for (i = 0; i < priv->num_grps; i++) {
+		struct gfarw_priv_grp *grp = &priv->gfarwgrp[i];
+		if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+			sprintf(gfarw_irq(grp, TX)->name, "%s%s%c%s",
+				dev->name, "_g", '0' + i, "_tx");
+			sprintf(gfarw_irq(grp, RX)->name, "%s%s%c%s",
+				dev->name, "_g", '0' + i, "_rx");
+			sprintf(gfarw_irq(grp, ER)->name, "%s%s%c%s",
+				dev->name, "_g", '0' + i, "_er");
+		} else
+			strcpy(gfarw_irq(grp, TX)->name, dev->name);
+	}
+
+	/* Initialize the filer table */
+	gfarw_init_filer_table(priv);
+
+	/* Print out the device info */
+	netdev_info(dev, "mac: %pM\n", dev->dev_addr);
+
+	/* Even more device info helps when determining which kernel
+	 * provided which set of benchmarks.
+	 */
+	netdev_info(dev, "Running with NAPI enabled\n");
+	for (i = 0; i < priv->num_rx_queues; i++)
+		netdev_info(dev, "RX BD ring size for Q[%d]: %d\n", i, RX_RING_SIZE);
+	for (i = 0; i < priv->num_tx_queues; i++)
+		netdev_info(dev, "TX BD ring size for Q[%d]: %d\n", i, priv->tx_queue[i]->tx_ring_size);
+
+#ifdef CONFIG_PROC_FS
+	{
+		char buf[128];
+		sprintf(buf, "work_%s_buf", dev->name);
+		if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_buffer_fops, priv)) {
+			printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+			return -ENOENT;
+		}
+		else {
+			printk(KERN_ERR "WORK: /proc/net/%s entry created!\n",buf);
+		}
+		sprintf(buf, "work_%s_ipv4", dev->name);
+		if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_ipv4_fops, priv)) {
+			printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+			return -ENOENT;
+		}
+		else {
+			printk(KERN_ERR "WORK: /proc/net/%s entry created!\n",buf);
+		}
+		sprintf(buf, "work_%s_mac", dev->name);
+		if (!proc_create_data(buf, S_IRUGO, init_net.proc_net, &work_mac_fops, priv)) {
+			printk(KERN_ERR "WORK: cannot create /proc/net/%s entry.\n", buf);
+			return -ENOENT;
+		}
+		else {
+			printk(KERN_ERR "WORK: /proc/net/%s entry created!\n",buf);
+		}
+	}
+#endif  /* CONFIG_PROC_FS */
+
+	return 0;
+
+register_fail:
+	unmap_group_regs(priv);
+	gfarw_free_rx_queues(priv);
+	gfarw_free_tx_queues(priv);
+	of_node_put(priv->phy_node);
+	of_node_put(priv->tbi_node);
+	free_gfarw_dev(priv);
+	return err;
+}
+
+static int gfarw_remove(struct platform_device *ofdev)
+{
+	struct gfarw_private *priv = platform_get_drvdata(ofdev);
+
+	of_node_put(priv->phy_node);
+	of_node_put(priv->tbi_node);
+
+	unregister_netdev(priv->ndev);
+	unmap_group_regs(priv);
+	gfarw_free_rx_queues(priv);
+	gfarw_free_tx_queues(priv);
+	free_gfarw_dev(priv);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int gfarw_suspend(struct device *dev)
+{
+	struct gfarw_private *priv = dev_get_drvdata(dev);
+	struct net_device *ndev = priv->ndev;
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+	int magic_packet = priv->wol_en &&
+			   (priv->device_flags &
+			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+
+	if (!netif_running(ndev))
+		return 0;
+
+	disable_napi(priv);
+	netif_tx_lock(ndev);
+	netif_device_detach(ndev);
+	netif_tx_unlock(ndev);
+
+	gfarw_halt(priv);
+
+	if (magic_packet) {
+		/* Enable interrupt on Magic Packet */
+		gfarw_write(&regs->imask, IMASK_MAG);
+
+		/* Enable Magic Packet mode */
+		tempval = gfarw_read(&regs->maccfg2);
+		tempval |= MACCFG2_MPEN;
+		gfarw_write(&regs->maccfg2, tempval);
+
+		/* re-enable the Rx block */
+		tempval = gfarw_read(&regs->maccfg1);
+		tempval |= MACCFG1_RX_EN;
+		gfarw_write(&regs->maccfg1, tempval);
+
+	} else {
+		phy_stop(priv->phydev);
+	}
+
+	return 0;
+}
+
+static int gfarw_resume(struct device *dev)
+{
+	struct gfarw_private *priv = dev_get_drvdata(dev);
+	struct net_device *ndev = priv->ndev;
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+	int magic_packet = priv->wol_en &&
+			   (priv->device_flags &
+			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+
+	if (!netif_running(ndev))
+		return 0;
+
+	if (magic_packet) {
+		/* Disable Magic Packet mode */
+		tempval = gfarw_read(&regs->maccfg2);
+		tempval &= ~MACCFG2_MPEN;
+		gfarw_write(&regs->maccfg2, tempval);
+	} else {
+		phy_start(priv->phydev);
+	}
+
+	gfarw_start(priv);
+
+	netif_device_attach(ndev);
+	enable_napi(priv);
+
+	return 0;
+}
+
+static int gfarw_restore(struct device *dev)
+{
+	struct gfarw_private *priv = dev_get_drvdata(dev);
+	struct net_device *ndev = priv->ndev;
+
+	if (!netif_running(ndev)) {
+		netif_device_attach(ndev);
+
+		return 0;
+	}
+
+	if (gfarw_init_bds(ndev)) {
+		free_skb_resources(priv);
+		return -ENOMEM;
+	}
+
+	gfarw_mac_reset(priv);
+
+	gfarw_init_tx_rx_base(priv);
+
+	gfarw_start(priv);
+
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	if (priv->phydev)
+		phy_start(priv->phydev);
+
+	netif_device_attach(ndev);
+	enable_napi(priv);
+
+	return 0;
+}
+
+static struct dev_pm_ops gfarw_pm_ops = {
+	.suspend = gfarw_suspend,
+	.resume = gfarw_resume,
+	.freeze = gfarw_suspend,
+	.thaw = gfarw_resume,
+	.restore = gfarw_restore,
+};
+
+#define GFAR_PM_OPS (&gfarw_pm_ops)
+
+#else
+
+#define GFAR_PM_OPS NULL
+
+#endif
+
+/* Reads the controller's registers to determine what interface
+ * connects it to the PHY.
+ */
+static phy_interface_t gfarw_get_interface(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 ecntrl;
+
+	ecntrl = gfarw_read(&regs->ecntrl);
+
+	if (ecntrl & ECNTRL_SGMII_MODE)
+		return PHY_INTERFACE_MODE_SGMII;
+
+	if (ecntrl & ECNTRL_TBI_MODE) {
+		if (ecntrl & ECNTRL_REDUCED_MODE)
+			return PHY_INTERFACE_MODE_RTBI;
+		else
+			return PHY_INTERFACE_MODE_TBI;
+	}
+
+	if (ecntrl & ECNTRL_REDUCED_MODE) {
+		if (ecntrl & ECNTRL_REDUCED_MII_MODE) {
+			return PHY_INTERFACE_MODE_RMII;
+		}
+		else {
+			phy_interface_t interface = priv->interface;
+
+			/* This isn't autodetected right now, so it must
+			 * be set by the device tree or platform code.
+			 */
+			if (interface == PHY_INTERFACE_MODE_RGMII_ID)
+				return PHY_INTERFACE_MODE_RGMII_ID;
+
+			return PHY_INTERFACE_MODE_RGMII;
+		}
+	}
+
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT)
+		return PHY_INTERFACE_MODE_GMII;
+
+	return PHY_INTERFACE_MODE_MII;
+}
+
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int init_phy(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	uint gigabit_support =
+		priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT ?
+		GFAR_SUPPORTED_GBIT : 0;
+	phy_interface_t interface;
+
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	interface = gfarw_get_interface(dev);
+
+	priv->phydev = of_phy_connect(dev, priv->phy_node, &adjust_link, 0,
+				      interface);
+	if (!priv->phydev) {
+		dev_err(&dev->dev, "could not attach to PHY\n");
+		return -ENODEV;
+	}
+
+	if (interface == PHY_INTERFACE_MODE_SGMII)
+		gfarw_configure_serdes(dev);
+
+	/* Remove any features not supported by the controller */
+	priv->phydev->supported &= (GFAR_SUPPORTED | gigabit_support);
+	priv->phydev->advertising = priv->phydev->supported;
+
+	/* Add support for flow control, but don't advertise it by default */
+	priv->phydev->supported |= (SUPPORTED_Pause | SUPPORTED_Asym_Pause);
+
+	return 0;
+}
+
+/* Initialize TBI PHY interface for communicating with the
+ * SERDES lynx PHY on the chip.  We communicate with this PHY
+ * through the MDIO bus on each controller, treating it as a
+ * "normal" PHY at the address found in the TBIPA register.  We assume
+ * that the TBIPA register is valid.  Either the MDIO bus code will set
+ * it to a value that doesn't conflict with other PHYs on the bus, or the
+ * value doesn't matter, as there are no other PHYs on the bus.
+ */
+static void gfarw_configure_serdes(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct phy_device *tbiphy;
+
+	if (!priv->tbi_node) {
+		dev_warn(&dev->dev, "error: SGMII mode requires that the "
+				    "device tree specify a tbi-handle\n");
+		return;
+	}
+
+	tbiphy = of_phy_find_device(priv->tbi_node);
+	if (!tbiphy) {
+		dev_err(&dev->dev, "error: Could not get TBI device\n");
+		return;
+	}
+
+	/* If the link is already up, we must already be ok, and don't need to
+	 * configure and reset the TBI<->SerDes link.  Maybe U-Boot configured
+	 * everything for us?  Resetting it takes the link down and requires
+	 * several seconds for it to come back.
+	 */
+	if (phy_read(tbiphy, MII_BMSR) & BMSR_LSTATUS)
+		return;
+
+	/* Single clk mode, mii mode off(for serdes communication) */
+	phy_write(tbiphy, MII_TBICON, TBICON_CLK_SELECT);
+
+	phy_write(tbiphy, MII_ADVERTISE,
+		  ADVERTISE_1000XFULL | ADVERTISE_1000XPAUSE |
+		  ADVERTISE_1000XPSE_ASYM);
+
+	phy_write(tbiphy, MII_BMCR,
+		  BMCR_ANENABLE | BMCR_ANRESTART | BMCR_FULLDPLX |
+		  BMCR_SPEED1000);
+}
+
+static int __gfarw_is_rx_idle(struct gfarw_private *priv)
+{
+	u32 res;
+
+	/* Normaly TSEC should not hang on GRS commands, so we should
+	 * actually wait for IEVENT_GRSC flag.
+	 */
+	if (!gfarw_has_errata(priv, GFAR_ERRATA_A002))
+		return 0;
+
+	/* Read the eTSEC register at offset 0xD1C. If bits 7-14 are
+	 * the same as bits 23-30, the eTSEC Rx is assumed to be idle
+	 * and the Rx can be safely reset.
+	 */
+	res = gfarw_read((void __iomem *)priv->gfarwgrp[0].regs + 0xd1c);
+	res &= 0x7f807f80;
+	if ((res & 0xffff) == (res >> 16))
+		return 1;
+
+	return 0;
+}
+
+/* Halt the receive and transmit queues */
+static void gfarw_halt_nodisable(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+	unsigned int timeout;
+	int stopped;
+
+	gfarw_ints_disable(priv);
+
+	if (gfarw_is_dma_stopped(priv))
+		return;
+
+	/* Stop the DMA, and wait for it to stop */
+	tempval = gfarw_read(&regs->dmactrl);
+	tempval |= (DMACTRL_GRS | DMACTRL_GTS);
+	gfarw_write(&regs->dmactrl, tempval);
+
+retry:
+	timeout = 1000;
+	while (!(stopped = gfarw_is_dma_stopped(priv)) && timeout) {
+		cpu_relax();
+		timeout--;
+	}
+
+	if (!timeout)
+		stopped = gfarw_is_dma_stopped(priv);
+
+	if (!stopped && !gfarw_is_rx_dma_stopped(priv) &&
+	    !__gfarw_is_rx_idle(priv))
+		goto retry;
+}
+
+/* Halt the receive and transmit queues */
+void gfarw_halt(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+
+	/* Dissable the Rx/Tx hw queues */
+	gfarw_write(&regs->rqueue, 0);
+	gfarw_write(&regs->tqueue, 0);
+
+	mdelay(10);
+
+	gfarw_halt_nodisable(priv);
+
+	/* Disable Rx/Tx DMA */
+	tempval = gfarw_read(&regs->maccfg1);
+	tempval &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+	gfarw_write(&regs->maccfg1, tempval);
+}
+
+void stop_gfarw(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+
+	netif_tx_stop_all_queues(dev);
+
+	smp_mb__before_atomic();
+	set_bit(GFAR_DOWN, &priv->state);
+	smp_mb__after_atomic();
+
+	disable_napi(priv);
+
+	/* disable ints and gracefully shut down Rx/Tx DMA */
+	gfarw_halt(priv);
+
+	phy_stop(priv->phydev);
+
+	free_skb_resources(priv);
+}
+
+static void free_skb_tx_queue(struct gfarw_priv_tx_q *tx_queue)
+{
+	struct txbd8 *txbdp;
+	struct gfarw_private *priv = netdev_priv(tx_queue->dev);
+	int i, j;
+
+	txbdp = tx_queue->tx_bd_base;
+
+	for (i = 0; i < tx_queue->tx_ring_size; i++) {
+		if (!tx_queue->tx_skbuff[i])
+			continue;
+
+		dma_unmap_single(priv->dev, be32_to_cpu(txbdp->bufPtr),
+				 be16_to_cpu(txbdp->length), DMA_TO_DEVICE);
+		txbdp->lstatus = 0;
+		for (j = 0; j < skb_shinfo(tx_queue->tx_skbuff[i])->nr_frags;
+		     j++) {
+			txbdp++;
+			dma_unmap_page(priv->dev, be32_to_cpu(txbdp->bufPtr),
+				       be16_to_cpu(txbdp->length),
+				       DMA_TO_DEVICE);
+		}
+		txbdp++;
+		dev_kfree_skb_any(tx_queue->tx_skbuff[i]);
+		tx_queue->tx_skbuff[i] = NULL;
+	}
+	kfree(tx_queue->tx_skbuff);
+	tx_queue->tx_skbuff = NULL;
+}
+
+static void free_skb_rx_queue(struct gfarw_priv_rx_q *rx_queue)
+{
+	struct rxbd8 *rxbdp;
+	struct gfarw_private *priv = netdev_priv(rx_queue->dev);
+	int i;
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		rxbdp = rx_queue->rx_pktbuff[i].rxbd;
+		if (rx_queue->rx_pktbuff[i].status == NET_BYPASS_STATUS_PACKET_IN_DMA) {
+
+			dma_unmap_single(priv->dev, be32_to_cpu(rxbdp->bufPtr), sizeof(rx_queue->rx_pktbuff[0].frame),
+			                 DMA_FROM_DEVICE);
+			rx_queue->rx_pktbuff[i].status = NET_BYPASS_STATUS_FREE_PACKET;
+		}
+		rxbdp->lstatus = 0;
+		rxbdp->bufPtr = 0;
+		rxbdp++;
+	}
+}
+
+/* If there are any tx skbs or rx skbs still around, free them.
+ * Then free tx_skbuff and rx_pktbuff
+ */
+static void free_skb_resources(struct gfarw_private *priv)
+{
+	struct gfarw_priv_tx_q *tx_queue = NULL;
+	struct gfarw_priv_rx_q *rx_queue = NULL;
+	int i;
+
+	/* Go through all the buffer descriptors and free their data buffers */
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		struct netdev_queue *txq;
+
+		tx_queue = priv->tx_queue[i];
+		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
+		if (tx_queue->tx_skbuff)
+			free_skb_tx_queue(tx_queue);
+		netdev_tx_reset_queue(txq);
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i];
+		if (rx_queue->rx_pktbuff)
+			free_skb_rx_queue(rx_queue);
+	}
+
+	dma_free_coherent(priv->dev,
+			  sizeof(struct txbd8) * priv->total_tx_ring_size +
+			  sizeof(struct rxbd8) * priv->total_rx_ring_size,
+			  priv->tx_queue[0]->tx_bd_base,
+			  priv->tx_queue[0]->tx_bd_dma_base);
+}
+
+void gfarw_start(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+	int i = 0;
+
+	/* Enable Rx/Tx hw queues */
+	gfarw_write(&regs->rqueue, priv->rqueue);
+	gfarw_write(&regs->tqueue, priv->tqueue);
+
+	/* Initialize DMACTRL to have WWR and WOP */
+	tempval = gfarw_read(&regs->dmactrl);
+	tempval |= DMACTRL_INIT_SETTINGS;
+	gfarw_write(&regs->dmactrl, tempval);
+
+	/* Make sure we aren't stopped */
+	tempval = gfarw_read(&regs->dmactrl);
+	tempval &= ~(DMACTRL_GRS | DMACTRL_GTS);
+	gfarw_write(&regs->dmactrl, tempval);
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfarwgrp[i].regs;
+		/* Clear THLT/RHLT, so that the DMA starts polling now */
+		gfarw_write(&regs->tstat, priv->gfarwgrp[i].tstat);
+		gfarw_write(&regs->rstat, priv->gfarwgrp[i].rstat);
+	}
+
+	/* Enable Rx/Tx DMA */
+	tempval = gfarw_read(&regs->maccfg1);
+	tempval |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
+	gfarw_write(&regs->maccfg1, tempval);
+
+	gfarw_ints_enable(priv);
+
+	priv->ndev->trans_start = jiffies; /* prevent tx timeout */
+}
+
+static void free_grp_irqs(struct gfarw_priv_grp *grp)
+{
+	free_irq(gfarw_irq(grp, TX)->irq, grp);
+	free_irq(gfarw_irq(grp, RX)->irq, grp);
+	free_irq(gfarw_irq(grp, ER)->irq, grp);
+}
+
+static int register_grp_irqs(struct gfarw_priv_grp *grp)
+{
+	struct gfarw_private *priv = grp->priv;
+	struct net_device *dev = priv->ndev;
+	int err;
+
+	/* If the device has multiple interrupts, register for
+	 * them.  Otherwise, only register for the one
+	 */
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+		/* Install our interrupt handlers for Error,
+		 * Transmit, and Receive
+		 */
+		err = request_irq(gfarw_irq(grp, ER)->irq, gfarw_error,
+				  IRQF_NO_SUSPEND,
+				  gfarw_irq(grp, ER)->name, grp);
+		if (err < 0) {
+			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+				  gfarw_irq(grp, ER)->irq);
+
+			goto err_irq_fail;
+		}
+		err = request_irq(gfarw_irq(grp, TX)->irq, gfarw_transmit, 0,
+				  gfarw_irq(grp, TX)->name, grp);
+		if (err < 0) {
+			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+				  gfarw_irq(grp, TX)->irq);
+			goto tx_irq_fail;
+		}
+		err = request_irq(gfarw_irq(grp, RX)->irq, gfarw_receive, 0,
+				  gfarw_irq(grp, RX)->name, grp);
+		if (err < 0) {
+			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+				  gfarw_irq(grp, RX)->irq);
+			goto rx_irq_fail;
+		}
+	} else {
+		err = request_irq(gfarw_irq(grp, TX)->irq, gfarw_interrupt,
+				  IRQF_NO_SUSPEND,
+				  gfarw_irq(grp, TX)->name, grp);
+		if (err < 0) {
+			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+				  gfarw_irq(grp, TX)->irq);
+			goto err_irq_fail;
+		}
+	}
+
+	return 0;
+
+rx_irq_fail:
+	free_irq(gfarw_irq(grp, TX)->irq, grp);
+tx_irq_fail:
+	free_irq(gfarw_irq(grp, ER)->irq, grp);
+err_irq_fail:
+	return err;
+
+}
+
+static void gfarw_free_irq(struct gfarw_private *priv)
+{
+	int i;
+
+	/* Free the IRQs */
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+		for (i = 0; i < priv->num_grps; i++)
+			free_grp_irqs(&priv->gfarwgrp[i]);
+	} else {
+		for (i = 0; i < priv->num_grps; i++)
+			free_irq(gfarw_irq(&priv->gfarwgrp[i], TX)->irq,
+				 &priv->gfarwgrp[i]);
+	}
+}
+
+static int gfarw_request_irq(struct gfarw_private *priv)
+{
+	int err, i, j;
+
+	for (i = 0; i < priv->num_grps; i++) {
+		err = register_grp_irqs(&priv->gfarwgrp[i]);
+		if (err) {
+			for (j = 0; j < i; j++)
+				free_grp_irqs(&priv->gfarwgrp[j]);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/* Bring the controller up and running */
+int startup_gfarw(struct net_device *ndev)
+{
+	struct gfarw_private *priv = netdev_priv(ndev);
+	int err;
+
+	gfarw_mac_reset(priv);
+
+	err = gfarw_alloc_skb_resources(ndev);
+	if (err)
+		return err;
+
+	gfarw_init_tx_rx_base(priv);
+
+	smp_mb__before_atomic();
+	clear_bit(GFAR_DOWN, &priv->state);
+	smp_mb__after_atomic();
+
+	/* Start Rx/Tx DMA and enable the interrupts */
+	gfarw_start(priv);
+
+	/* force link state update after mac reset */
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	phy_start(priv->phydev);
+
+	enable_napi(priv);
+
+	netif_tx_wake_all_queues(ndev);
+
+	return 0;
+}
+
+/* Called when something needs to use the ethernet device
+ * Returns 0 for success.
+ */
+static int gfarw_enet_open(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	int err;
+
+	err = init_phy(dev);
+	if (err)
+		return err;
+
+	err = gfarw_request_irq(priv);
+	if (err)
+		return err;
+
+	err = startup_gfarw(dev);
+	if (err)
+		return err;
+
+	return err;
+}
+
+static inline struct txfcb *gfarw_add_fcb(struct sk_buff *skb)
+{
+	struct txfcb *fcb = (struct txfcb *)skb_push(skb, GMAC_FCB_LEN);
+
+	memset(fcb, 0, GMAC_FCB_LEN);
+
+	return fcb;
+}
+
+static inline void gfarw_tx_checksum(struct sk_buff *skb, struct txfcb *fcb,
+				    int fcb_length)
+{
+	/* If we're here, it's a IP packet with a TCP or UDP
+	 * payload.  We set it to checksum, using a pseudo-header
+	 * we provide
+	 */
+	u8 flags = TXFCB_DEFAULT;
+
+	/* Tell the controller what the protocol is
+	 * And provide the already calculated phcs
+	 */
+	if (ip_hdr(skb)->protocol == IPPROTO_UDP) {
+		flags |= TXFCB_UDP;
+		fcb->phcs = (__force __be16)(udp_hdr(skb)->check);
+	} else
+		fcb->phcs = (__force __be16)(tcp_hdr(skb)->check);
+
+	/* l3os is the distance between the start of the
+	 * frame (skb->data) and the start of the IP hdr.
+	 * l4os is the distance between the start of the
+	 * l3 hdr and the l4 hdr
+	 */
+	fcb->l3os = (u8)(skb_network_offset(skb) - fcb_length);
+	fcb->l4os = skb_network_header_len(skb);
+
+	fcb->flags = flags;
+}
+
+void inline gfarw_tx_vlan(struct sk_buff *skb, struct txfcb *fcb)
+{
+	fcb->flags |= TXFCB_VLN;
+	fcb->vlctl = cpu_to_be16(skb_vlan_tag_get(skb));
+}
+
+static inline struct txbd8 *skip_txbd(struct txbd8 *bdp, int stride,
+				      struct txbd8 *base, int ring_size)
+{
+	struct txbd8 *new_bd = bdp + stride;
+
+	return (new_bd >= (base + ring_size)) ? (new_bd - ring_size) : new_bd;
+}
+
+static inline struct txbd8 *next_txbd(struct txbd8 *bdp, struct txbd8 *base,
+				      int ring_size)
+{
+	return skip_txbd(bdp, 1, base, ring_size);
+}
+
+/* eTSEC12: csum generation not supported for some fcb offsets */
+static inline bool gfarw_csum_errata_12(struct gfarw_private *priv,
+				       unsigned long fcb_addr)
+{
+	return (gfarw_has_errata(priv, GFAR_ERRATA_12) &&
+	       (fcb_addr % 0x20) > 0x18);
+}
+
+/* eTSEC76: csum generation for frames larger than 2500 may
+ * cause excess delays before start of transmission
+ */
+static inline bool gfarw_csum_errata_76(struct gfarw_private *priv,
+				       unsigned int len)
+{
+	return (gfarw_has_errata(priv, GFAR_ERRATA_76) &&
+	       (len > 2500));
+}
+
+/* This is called by the kernel when a frame is ready for transmission.
+ * It is pointed to by the dev->hard_start_xmit function pointer
+ */
+static int gfarw_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct gfarw_priv_tx_q *tx_queue = NULL;
+	struct netdev_queue *txq;
+	struct gfarw __iomem *regs = NULL;
+	struct txfcb *fcb = NULL;
+	struct txbd8 *txbdp, *txbdp_start, *base, *txbdp_tstamp = NULL;
+	u32 lstatus;
+	int i, rq = 0;
+	int do_tstamp, do_csum, do_vlan;
+	u32 bufaddr;
+	unsigned int nr_frags, nr_txbds, bytes_sent, fcb_len = 0;
+
+	rq = skb->queue_mapping;
+	tx_queue = priv->tx_queue[rq];
+	txq = netdev_get_tx_queue(dev, rq);
+	base = tx_queue->tx_bd_base;
+	regs = tx_queue->grp->regs;
+
+	do_csum = (CHECKSUM_PARTIAL == skb->ip_summed);
+	do_vlan = skb_vlan_tag_present(skb);
+	do_tstamp = (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+		    priv->hwts_tx_en;
+
+	if (do_csum || do_vlan)
+		fcb_len = GMAC_FCB_LEN;
+
+	/* check if time stamp should be generated */
+	if (unlikely(do_tstamp))
+		fcb_len = GMAC_FCB_LEN + GMAC_TXPAL_LEN;
+
+	/* make space for additional header when fcb is needed */
+	if (fcb_len && unlikely(skb_headroom(skb) < fcb_len)) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, fcb_len);
+		if (!skb_new) {
+			dev->stats.tx_errors++;
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
+
+		if (skb->sk)
+			skb_set_owner_w(skb_new, skb->sk);
+		dev_consume_skb_any(skb);
+		skb = skb_new;
+	}
+
+	/* total number of fragments in the SKB */
+	nr_frags = skb_shinfo(skb)->nr_frags;
+
+	/* calculate the required number of TxBDs for this skb */
+	if (unlikely(do_tstamp))
+		nr_txbds = nr_frags + 2;
+	else
+		nr_txbds = nr_frags + 1;
+
+	/* check if there is space to queue this packet */
+	if (nr_txbds > tx_queue->num_txbdfree) {
+		/* no space, stop the queue */
+		netif_tx_stop_queue(txq);
+		dev->stats.tx_fifo_errors++;
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Update transmit stats */
+	bytes_sent = skb->len;
+	tx_queue->stats.tx_bytes += bytes_sent;
+	/* keep Tx bytes on wire for BQL accounting */
+	GFAR_CB(skb)->bytes_sent = bytes_sent;
+	tx_queue->stats.tx_packets++;
+
+	txbdp = txbdp_start = tx_queue->cur_tx;
+	lstatus = be32_to_cpu(txbdp->lstatus);
+
+	/* Time stamp insertion requires one additional TxBD */
+	if (unlikely(do_tstamp))
+		txbdp_tstamp = txbdp = next_txbd(txbdp, base,
+						 tx_queue->tx_ring_size);
+
+	if (nr_frags == 0) {
+		if (unlikely(do_tstamp)) {
+			u32 lstatus_ts = be32_to_cpu(txbdp_tstamp->lstatus);
+
+			lstatus_ts |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+			txbdp_tstamp->lstatus = cpu_to_be32(lstatus_ts);
+		} else {
+			lstatus |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+		}
+	} else {
+		/* Place the fragment addresses and lengths into the TxBDs */
+		for (i = 0; i < nr_frags; i++) {
+			unsigned int frag_len;
+			/* Point at the next BD, wrapping as needed */
+			txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+
+			frag_len = skb_shinfo(skb)->frags[i].size;
+
+			lstatus = be32_to_cpu(txbdp->lstatus) | frag_len |
+				  BD_LFLAG(TXBD_READY);
+
+			/* Handle the last BD specially */
+			if (i == nr_frags - 1)
+				lstatus |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+
+			bufaddr = skb_frag_dma_map(priv->dev,
+						   &skb_shinfo(skb)->frags[i],
+						   0,
+						   frag_len,
+						   DMA_TO_DEVICE);
+			if (unlikely(dma_mapping_error(priv->dev, bufaddr)))
+				goto dma_map_err;
+
+			/* set the TxBD length and buffer pointer */
+			txbdp->bufPtr = cpu_to_be32(bufaddr);
+			txbdp->lstatus = cpu_to_be32(lstatus);
+		}
+
+		lstatus = be32_to_cpu(txbdp_start->lstatus);
+	}
+
+	/* Add TxPAL between FCB and frame if required */
+	if (unlikely(do_tstamp)) {
+		skb_push(skb, GMAC_TXPAL_LEN);
+		memset(skb->data, 0, GMAC_TXPAL_LEN);
+	}
+
+	/* Add TxFCB if required */
+	if (fcb_len) {
+		fcb = gfarw_add_fcb(skb);
+		lstatus |= BD_LFLAG(TXBD_TOE);
+	}
+
+	/* Set up checksumming */
+	if (do_csum) {
+		gfarw_tx_checksum(skb, fcb, fcb_len);
+
+		if (unlikely(gfarw_csum_errata_12(priv, (unsigned long)fcb)) ||
+		    unlikely(gfarw_csum_errata_76(priv, skb->len))) {
+			__skb_pull(skb, GMAC_FCB_LEN);
+			skb_checksum_help(skb);
+			if (do_vlan || do_tstamp) {
+				/* put back a new fcb for vlan/tstamp TOE */
+				fcb = gfarw_add_fcb(skb);
+			} else {
+				/* Tx TOE not used */
+				lstatus &= ~(BD_LFLAG(TXBD_TOE));
+				fcb = NULL;
+			}
+		}
+	}
+
+	if (do_vlan)
+		gfarw_tx_vlan(skb, fcb);
+
+	/* Setup tx hardware time stamping if requested */
+	if (unlikely(do_tstamp)) {
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+		fcb->ptp = 1;
+	}
+
+	bufaddr = dma_map_single(priv->dev, skb->data, skb_headlen(skb),
+				 DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, bufaddr)))
+		goto dma_map_err;
+
+	txbdp_start->bufPtr = cpu_to_be32(bufaddr);
+
+	/* If time stamping is requested one additional TxBD must be set up. The
+	 * first TxBD points to the FCB and must have a data length of
+	 * GMAC_FCB_LEN. The second TxBD points to the actual frame data with
+	 * the full frame length.
+	 */
+	if (unlikely(do_tstamp)) {
+		u32 lstatus_ts = be32_to_cpu(txbdp_tstamp->lstatus);
+
+		bufaddr = be32_to_cpu(txbdp_start->bufPtr);
+		bufaddr += fcb_len;
+		lstatus_ts |= BD_LFLAG(TXBD_READY) |
+			      (skb_headlen(skb) - fcb_len);
+
+		txbdp_tstamp->bufPtr = cpu_to_be32(bufaddr);
+		txbdp_tstamp->lstatus = cpu_to_be32(lstatus_ts);
+		lstatus |= BD_LFLAG(TXBD_CRC | TXBD_READY) | GMAC_FCB_LEN;
+	} else {
+		lstatus |= BD_LFLAG(TXBD_CRC | TXBD_READY) | skb_headlen(skb);
+	}
+
+	netdev_tx_sent_queue(txq, bytes_sent);
+
+	gfarw_wmb();
+
+	txbdp_start->lstatus = cpu_to_be32(lstatus);
+
+	gfarw_wmb(); /* force lstatus write before tx_skbuff */
+
+	tx_queue->tx_skbuff[tx_queue->skb_curtx] = skb;
+
+	/* Update the current skb pointer to the next entry we will use
+	 * (wrapping if necessary)
+	 */
+	tx_queue->skb_curtx = (tx_queue->skb_curtx + 1) &
+			      TX_RING_MOD_MASK(tx_queue->tx_ring_size);
+
+	tx_queue->cur_tx = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+
+	/* We can work in parallel with gfarw_clean_tx_ring(), except
+	 * when modifying num_txbdfree. Note that we didn't grab the lock
+	 * when we were reading the num_txbdfree and checking for available
+	 * space, that's because outside of this function it can only grow.
+	 */
+	spin_lock_bh(&tx_queue->txlock);
+	/* reduce TxBD free count */
+	tx_queue->num_txbdfree -= (nr_txbds);
+	spin_unlock_bh(&tx_queue->txlock);
+
+	/* If the next BD still needs to be cleaned up, then the bds
+	 * are full.  We need to tell the kernel to stop sending us stuff.
+	 */
+	if (!tx_queue->num_txbdfree) {
+		netif_tx_stop_queue(txq);
+
+		dev->stats.tx_fifo_errors++;
+	}
+
+	/* Tell the DMA to go go go */
+	gfarw_write(&regs->tstat, TSTAT_CLEAR_THALT >> tx_queue->qindex);
+
+	return NETDEV_TX_OK;
+
+dma_map_err:
+	txbdp = next_txbd(txbdp_start, base, tx_queue->tx_ring_size);
+	if (do_tstamp)
+		txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+	for (i = 0; i < nr_frags; i++) {
+		lstatus = be32_to_cpu(txbdp->lstatus);
+		if (!(lstatus & BD_LFLAG(TXBD_READY)))
+			break;
+
+		lstatus &= ~BD_LFLAG(TXBD_READY);
+		txbdp->lstatus = cpu_to_be32(lstatus);
+		bufaddr = be32_to_cpu(txbdp->bufPtr);
+		dma_unmap_page(priv->dev, bufaddr, be16_to_cpu(txbdp->length),
+			       DMA_TO_DEVICE);
+		txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+	}
+	gfarw_wmb();
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+/* Stops the kernel queue, and halts the controller */
+static int gfarw_close(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+
+	cancel_work_sync(&priv->reset_task);
+	stop_gfarw(dev);
+
+	/* Disconnect from the PHY */
+	phy_disconnect(priv->phydev);
+	priv->phydev = NULL;
+
+	gfarw_free_irq(priv);
+
+	return 0;
+}
+
+/* Changes the mac address if the controller is not running. */
+static int gfarw_set_mac_address(struct net_device *dev)
+{
+	gfarw_set_mac_for_addr(dev, 0, dev->dev_addr);
+
+	return 0;
+}
+
+static int gfarw_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	int frame_size = new_mtu + ETH_HLEN;
+
+	if ((frame_size < 64) || (frame_size > JUMBO_FRAME_SIZE)) {
+		netif_err(priv, drv, dev, "Invalid MTU setting\n");
+		return -EINVAL;
+	}
+
+	while (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))
+		cpu_relax();
+
+	if (dev->flags & IFF_UP)
+		stop_gfarw(dev);
+
+	dev->mtu = new_mtu;
+
+	if (dev->flags & IFF_UP)
+		startup_gfarw(dev);
+
+	clear_bit_unlock(GFAR_RESETTING, &priv->state);
+
+	return 0;
+}
+
+void reset_gfarw(struct net_device *ndev)
+{
+	struct gfarw_private *priv = netdev_priv(ndev);
+
+	while (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))
+		cpu_relax();
+
+	stop_gfarw(ndev);
+	startup_gfarw(ndev);
+
+	clear_bit_unlock(GFAR_RESETTING, &priv->state);
+}
+
+/* gfarw_reset_task gets scheduled when a packet has not been
+ * transmitted after a set amount of time.
+ * For now, assume that clearing out all the structures, and
+ * starting over will fix the problem.
+ */
+static void gfarw_reset_task(struct work_struct *work)
+{
+	struct gfarw_private *priv = container_of(work, struct gfarw_private,
+						 reset_task);
+	reset_gfarw(priv->ndev);
+}
+
+static void gfarw_timeout(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+
+	dev->stats.tx_errors++;
+	schedule_work(&priv->reset_task);
+}
+
+static void gfarw_align_skb(struct sk_buff *skb)
+{
+	/* We need the data buffer to be aligned properly.  We will reserve
+	 * as many bytes as needed to align the data properly
+	 */
+	skb_reserve(skb, RXBUF_ALIGNMENT -
+		    (((unsigned long) skb->data) & (RXBUF_ALIGNMENT - 1)));
+}
+
+/* Interrupt Handler for Transmit complete */
+static void gfarw_clean_tx_ring(struct gfarw_priv_tx_q *tx_queue)
+{
+	struct net_device *dev = tx_queue->dev;
+	struct netdev_queue *txq;
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct txbd8 *bdp, *next = NULL;
+	struct txbd8 *lbdp = NULL;
+	struct txbd8 *base = tx_queue->tx_bd_base;
+	struct sk_buff *skb;
+	int skb_dirtytx;
+	int tx_ring_size = tx_queue->tx_ring_size;
+	int frags = 0, nr_txbds = 0;
+	int i;
+	int howmany = 0;
+	int tqi = tx_queue->qindex;
+	unsigned int bytes_sent = 0;
+	u32 lstatus;
+	size_t buflen;
+
+	txq = netdev_get_tx_queue(dev, tqi);
+	bdp = tx_queue->dirty_tx;
+	skb_dirtytx = tx_queue->skb_dirtytx;
+
+	while ((skb = tx_queue->tx_skbuff[skb_dirtytx])) {
+
+		frags = skb_shinfo(skb)->nr_frags;
+
+		/* When time stamping, one additional TxBD must be freed.
+		 * Also, we need to dma_unmap_single() the TxPAL.
+		 */
+		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
+			nr_txbds = frags + 2;
+		else
+			nr_txbds = frags + 1;
+
+		lbdp = skip_txbd(bdp, nr_txbds - 1, base, tx_ring_size);
+
+		lstatus = be32_to_cpu(lbdp->lstatus);
+
+		/* Only clean completed frames */
+		if ((lstatus & BD_LFLAG(TXBD_READY)) &&
+		    (lstatus & BD_LENGTH_MASK))
+			break;
+
+		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
+			next = next_txbd(bdp, base, tx_ring_size);
+			buflen = be16_to_cpu(next->length) +
+				 GMAC_FCB_LEN + GMAC_TXPAL_LEN;
+		} else
+			buflen = be16_to_cpu(bdp->length);
+
+		dma_unmap_single(priv->dev, be32_to_cpu(bdp->bufPtr),
+				 buflen, DMA_TO_DEVICE);
+
+		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
+			struct skb_shared_hwtstamps shhwtstamps;
+			u64 *ns = (u64*) (((u32)skb->data + 0x10) & ~0x7);
+
+			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+			shhwtstamps.hwtstamp = ns_to_ktime(*ns);
+			skb_pull(skb, GMAC_FCB_LEN + GMAC_TXPAL_LEN);
+			skb_tstamp_tx(skb, &shhwtstamps);
+			gfarw_clear_txbd_status(bdp);
+			bdp = next;
+		}
+
+		gfarw_clear_txbd_status(bdp);
+		bdp = next_txbd(bdp, base, tx_ring_size);
+
+		for (i = 0; i < frags; i++) {
+			dma_unmap_page(priv->dev, be32_to_cpu(bdp->bufPtr),
+				       be16_to_cpu(bdp->length),
+				       DMA_TO_DEVICE);
+			gfarw_clear_txbd_status(bdp);
+			bdp = next_txbd(bdp, base, tx_ring_size);
+		}
+
+		bytes_sent += GFAR_CB(skb)->bytes_sent;
+
+		dev_kfree_skb_any(skb);
+
+		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
+
+		skb_dirtytx = (skb_dirtytx + 1) &
+			      TX_RING_MOD_MASK(tx_ring_size);
+
+		howmany++;
+		spin_lock(&tx_queue->txlock);
+		tx_queue->num_txbdfree += nr_txbds;
+		spin_unlock(&tx_queue->txlock);
+	}
+
+	/* If we freed a buffer, we can restart transmission, if necessary */
+	if (tx_queue->num_txbdfree &&
+	    netif_tx_queue_stopped(txq) &&
+	    !(test_bit(GFAR_DOWN, &priv->state)))
+		netif_wake_subqueue(priv->ndev, tqi);
+
+	/* Update dirty indicators */
+	tx_queue->skb_dirtytx = skb_dirtytx;
+	tx_queue->dirty_tx = bdp;
+
+	netdev_tx_completed_queue(txq, howmany, bytes_sent);
+}
+
+static struct sk_buff *gfarw_alloc_skb(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+
+	skb = netdev_alloc_skb(dev, priv->rx_buffer_size + RXBUF_ALIGNMENT);
+	if (!skb)
+		return NULL;
+
+	gfarw_align_skb(skb);
+
+	return skb;
+}
+
+static inline void count_errors(unsigned short status, struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &dev->stats;
+	struct gfarw_extra_stats *estats = &priv->extra_stats;
+
+	/* If the packet was truncated, none of the other errors matter */
+	if (status & RXBD_TRUNCATED) {
+		stats->rx_length_errors++;
+
+		atomic64_inc(&estats->rx_trunc);
+
+		return;
+	}
+	/* Count the errors, if there were any */
+	if (status & (RXBD_LARGE | RXBD_SHORT)) {
+		stats->rx_length_errors++;
+
+		if (status & RXBD_LARGE)
+			atomic64_inc(&estats->rx_large);
+		else
+			atomic64_inc(&estats->rx_short);
+	}
+	if (status & RXBD_NONOCTET) {
+		stats->rx_frame_errors++;
+		atomic64_inc(&estats->rx_nonoctet);
+	}
+	if (status & RXBD_CRCERR) {
+		atomic64_inc(&estats->rx_crcerr);
+		stats->rx_crc_errors++;
+	}
+	if (status & RXBD_OVERRUN) {
+		atomic64_inc(&estats->rx_overrun);
+		stats->rx_crc_errors++;
+	}
+}
+
+irqreturn_t gfarw_receive(int irq, void *grp_id)
+{
+	struct gfarw_priv_grp *grp = (struct gfarw_priv_grp *)grp_id;
+	unsigned long flags;
+	u32 imask;
+
+	if (likely(napi_schedule_prep(&grp->napi_rx))) {
+		spin_lock_irqsave(&grp->grplock, flags);
+		imask = gfarw_read(&grp->regs->imask);
+		imask &= IMASK_RX_DISABLED;
+		gfarw_write(&grp->regs->imask, imask);
+		spin_unlock_irqrestore(&grp->grplock, flags);
+		__napi_schedule(&grp->napi_rx);
+	} else {
+		/* Clear IEVENT, so interrupts aren't called again
+		 * because of the packets that have already arrived.
+		 */
+		gfarw_write(&grp->regs->ievent, IEVENT_RX_MASK);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* Interrupt Handler for Transmit complete */
+static irqreturn_t gfarw_transmit(int irq, void *grp_id)
+{
+	struct gfarw_priv_grp *grp = (struct gfarw_priv_grp *)grp_id;
+	unsigned long flags;
+	u32 imask;
+
+	if (likely(napi_schedule_prep(&grp->napi_tx))) {
+		spin_lock_irqsave(&grp->grplock, flags);
+		imask = gfarw_read(&grp->regs->imask);
+		imask &= IMASK_TX_DISABLED;
+		gfarw_write(&grp->regs->imask, imask);
+		spin_unlock_irqrestore(&grp->grplock, flags);
+		__napi_schedule(&grp->napi_tx);
+	} else {
+		/* Clear IEVENT, so interrupts aren't called again
+		 * because of the packets that have already arrived.
+		 */
+		gfarw_write(&grp->regs->ievent, IEVENT_TX_MASK);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static inline void gfarw_rx_checksum(struct sk_buff *skb, struct rxfcb *fcb)
+{
+	/* If valid headers were found, and valid sums
+	 * were verified, then we tell the kernel that no
+	 * checksumming is necessary.  Otherwise, it is [FIXME]
+	 */
+	if ((be16_to_cpu(fcb->flags) & RXFCB_CSUM_MASK) ==
+	    (RXFCB_CIP | RXFCB_CTU))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	else
+		skb_checksum_none_assert(skb);
+}
+
+/* gfarw_process_frame() -- handle one incoming packet if skb isn't NULL. */
+static void gfarw_process_frame(struct net_device *dev, struct sk_buff *skb,
+			       int amount_pull, struct napi_struct *napi)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct rxfcb *fcb = NULL;
+
+	/* fcb is at the beginning if exists */
+	fcb = (struct rxfcb *)skb->data;
+
+	/* Remove the FCB from the skb
+	 * Remove the padded bytes, if there are any
+	 */
+	if (amount_pull) {
+		skb_record_rx_queue(skb, fcb->rq);
+		skb_pull(skb, amount_pull);
+	}
+
+	/* Get receive timestamp from the skb */
+	if (priv->hwts_rx_en) {
+		struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+		u64 *ns = (u64 *) skb->data;
+
+		memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+		shhwtstamps->hwtstamp = ns_to_ktime(*ns);
+	}
+
+	if (priv->padding)
+		skb_pull(skb, priv->padding);
+
+	if (dev->features & NETIF_F_RXCSUM)
+		gfarw_rx_checksum(skb, fcb);
+
+	/* Tell the skb what kind of packet this is */
+	skb->protocol = eth_type_trans(skb, dev);
+
+	/* There's need to check for NETIF_F_HW_VLAN_CTAG_RX here.
+	 * Even if vlan rx accel is disabled, on some chips
+	 * RXFCB_VLN is pseudo randomly set.
+	 */
+	if (dev->features & NETIF_F_HW_VLAN_CTAG_RX &&
+	    be16_to_cpu(fcb->flags) & RXFCB_VLN)
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+				       be16_to_cpu(fcb->vlctl));
+
+	/* Send the packet up the stack */
+	napi_gro_receive(napi, skb);
+
+}
+
+
+static inline bool is_multicast_ip_addr(int addr) {
+	return addr & 0xE0000000;
+}
+
+/* gfarw_clean_rx_ring_work() -- Processes each frame in the rx ring
+ * until the budget/quota has been reached. Returns the number
+ * of frames handled
+ */
+int gfarw_clean_rx_ring_work(struct gfarw_priv_rx_q *rx_queue, int rx_work_limit)
+{
+	struct net_device *dev = rx_queue->dev;
+	int howmany = 0;
+	struct gfarw_private *priv = netdev_priv(dev);
+	int amount_pull = priv->uses_rxfcb ? GMAC_FCB_LEN : 0;
+	struct gfarw_priv_rx_pkt *free, *ptr;
+	u64 now = ktime_get_ns();
+	static u64 next_warn = 0;
+	static int dropped_slow = 0;
+
+	ptr = &rx_queue->rx_pktbuff[rx_queue->rx_currpkt];
+	while (!((be16_to_cpu(ptr->rxbd->status) & RXBD_EMPTY) || (--rx_work_limit < 0))) {
+
+		rmb();
+
+		// Unmaps ptr->frame (which was mapped to ptr->rxbd->bufPtr before)
+		dma_unmap_single(priv->dev, be32_to_cpu(ptr->rxbd->bufPtr),
+		                 sizeof(ptr->frame), DMA_FROM_DEVICE);
+
+		if (unlikely(!(be16_to_cpu(ptr->rxbd->status) & RXBD_ERR) && be16_to_cpu(ptr->rxbd->length) > priv->rx_buffer_size)) {
+			ptr->rxbd->status = cpu_to_be16(RXBD_LARGE);
+		}
+
+		if (unlikely(dropped_slow > 0 && now > next_warn)) {
+			//printk(KERN_ERR "Dropped %d pkts in last 10 seconds.\n", dropped_slow);
+			printk(KERN_ERR "Received more data than can be handled! Dropped %d pkts in last 10 seconds.\n", dropped_slow);
+			dropped_slow = 0;
+			next_warn = 0;
+		}
+		if (unlikely(ptr->status != NET_BYPASS_STATUS_PACKET_IN_DMA)) {
+			rx_queue->stats.rx_dropped++;
+			howmany++;
+			// rx_errors are increased, when there are packets but no free DMA slot (ring-buffer)
+
+			dropped_slow++;
+			// trigger warning in 10 seconds
+			if (next_warn == 0) {
+				next_warn = now + 10LL*1000*1000*1000;
+			}
+
+			break;
+		}
+		else if (unlikely(!(be16_to_cpu(ptr->rxbd->status) & RXBD_LAST) || be16_to_cpu(ptr->rxbd->status) & RXBD_ERR)) {
+			count_errors(be16_to_cpu(ptr->rxbd->status), dev);
+			ptr->status = NET_BYPASS_STATUS_INVALID_PACKET;
+			ptr->size = 0;
+			printk(KERN_ERR "%s(): Received invalid packet!\n", __func__);
+		}
+		else {
+			struct ethhdr *eth;
+			struct iphdr *ipv4;
+
+			rx_queue->stats.rx_packets++;
+			howmany++;
+
+			ptr->offset = priv->padding + amount_pull;
+			ptr->size = be16_to_cpu(ptr->rxbd->length) - ETH_FCS_LEN - ptr->offset;
+
+			eth  = (struct ethhdr *)(ptr->frame + ptr->offset);
+			ipv4 = (struct iphdr *) (ptr->frame + ptr->offset + ETH_HLEN);
+
+
+			if (eth->h_proto == ETH_P_IP &&
+			    ((ipv4->daddr != priv->f_ipv4 && ether_addr_equal(eth->h_dest, priv->f_mac)) ||
+			     (is_multicast_ip_addr(ipv4->daddr) && is_multicast_ether_addr(eth->h_dest))
+			    )
+			   ) {
+
+				ptr->status = NET_BYPASS_STATUS_USER_PACKET;
+			}
+			else {
+				struct sk_buff *skb;
+				int pkt_len;
+
+				pkt_len = be16_to_cpu(ptr->rxbd->length) - ETH_FCS_LEN;
+
+				skb = gfarw_alloc_skb(dev);
+				if (!skb) {
+					printk(KERN_ERR "Failed to allocate SKB!\n");
+					return howmany;
+				}
+
+				memcpy(skb->data, ptr->frame, be16_to_cpu(ptr->rxbd->length));
+				ptr->status = NET_BYPASS_STATUS_HANDLED_BY_KERNEL;		// we are done with this packet
+
+				/* Remove the FCS from the packet length */
+				skb_put(skb, pkt_len);
+				rx_queue->stats.rx_bytes += pkt_len;
+				skb_record_rx_queue(skb, rx_queue->qindex);
+
+				gfarw_process_frame(dev, skb, amount_pull, &rx_queue->grp->napi_rx);
+			}
+		}
+
+		if (++(rx_queue->rx_currpkt) >= RX_RING_SIZE) rx_queue->rx_currpkt = 0;
+		ptr = &rx_queue->rx_pktbuff[rx_queue->rx_currpkt];
+	}
+
+	free = &rx_queue->rx_pktbuff[rx_queue->rx_freepkt];
+	while (free->status == NET_BYPASS_STATUS_FREE_PACKET) {
+		//printk(KERN_INFO "Freeing %d -> dma\n", rx_queue->rx_freepkt);
+
+		free->size = 0;
+		free->status = NET_BYPASS_STATUS_PACKET_IN_DMA;
+
+		// Maps ptr->frame to ptr->rxbd->bufPtr
+		free->rxbd->bufPtr = cpu_to_be32(dma_map_single(priv->dev, free->frame,
+		                                                sizeof(free->frame), DMA_FROM_DEVICE));
+
+		/* Setup the new bdp */
+		gfarw_init_rxbdp(rx_queue, free->rxbd, be32_to_cpu(free->rxbd->bufPtr));
+
+		/* Update Last Free RxBD pointer for LFC */
+		if (unlikely(rx_queue->rfbptr && priv->tx_actual_en))
+			gfarw_write(rx_queue->rfbptr, (u32)free->rxbd);
+
+		rx_queue->rx_freepkt ++;
+		if (rx_queue->rx_freepkt >= RX_RING_SIZE) rx_queue->rx_freepkt = 0;
+		free = &rx_queue->rx_pktbuff[rx_queue->rx_freepkt];
+	}
+
+	return howmany;
+}
+
+static int gfarw_poll_rx_sq(struct napi_struct *napi, int budget)
+{
+	struct gfarw_priv_grp *gfarwgrp =
+		container_of(napi, struct gfarw_priv_grp, napi_rx);
+	struct gfarw __iomem *regs = gfarwgrp->regs;
+	struct gfarw_priv_rx_q *rx_queue = gfarwgrp->rx_queue;
+	int work_done = 0;
+
+	/* Clear IEVENT, so interrupts aren't called again
+	 * because of the packets that have already arrived
+	 */
+	gfarw_write(&regs->ievent, IEVENT_RX_MASK);
+
+	work_done = gfarw_clean_rx_ring_work(rx_queue, budget);
+
+	if (work_done < budget) {
+		u32 imask;
+		napi_complete(napi);
+		/* Clear the halt bit in RSTAT */
+		gfarw_write(&regs->rstat, gfarwgrp->rstat);
+
+		spin_lock_irq(&gfarwgrp->grplock);
+		imask = gfarw_read(&regs->imask);
+		imask |= IMASK_RX_DEFAULT;
+		gfarw_write(&regs->imask, imask);
+		spin_unlock_irq(&gfarwgrp->grplock);
+	}
+
+	return work_done;
+}
+
+static int gfarw_poll_tx_sq(struct napi_struct *napi, int budget)
+{
+	struct gfarw_priv_grp *gfarwgrp =
+		container_of(napi, struct gfarw_priv_grp, napi_tx);
+	struct gfarw __iomem *regs = gfarwgrp->regs;
+	struct gfarw_priv_tx_q *tx_queue = gfarwgrp->tx_queue;
+	u32 imask;
+
+	/* Clear IEVENT, so interrupts aren't called again
+	 * because of the packets that have already arrived
+	 */
+	gfarw_write(&regs->ievent, IEVENT_TX_MASK);
+
+	/* run Tx cleanup to completion */
+	if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx])
+		gfarw_clean_tx_ring(tx_queue);
+
+	napi_complete(napi);
+
+	spin_lock_irq(&gfarwgrp->grplock);
+	imask = gfarw_read(&regs->imask);
+	imask |= IMASK_TX_DEFAULT;
+	gfarw_write(&regs->imask, imask);
+	spin_unlock_irq(&gfarwgrp->grplock);
+
+	return 0;
+}
+
+static int gfarw_poll_rx(struct napi_struct *napi, int budget)
+{
+	struct gfarw_priv_grp *gfarwgrp =
+		container_of(napi, struct gfarw_priv_grp, napi_rx);
+	struct gfarw_private *priv = gfarwgrp->priv;
+	struct gfarw __iomem *regs = gfarwgrp->regs;
+	struct gfarw_priv_rx_q *rx_queue = NULL;
+	int work_done = 0, work_done_per_q = 0;
+	int i, budget_per_q = 0;
+	unsigned long rstat_rxf;
+	int num_act_queues;
+
+	/* Clear IEVENT, so interrupts aren't called again
+	 * because of the packets that have already arrived
+	 */
+	gfarw_write(&regs->ievent, IEVENT_RX_MASK);
+
+	rstat_rxf = gfarw_read(&regs->rstat) & RSTAT_RXF_MASK;
+
+	num_act_queues = bitmap_weight(&rstat_rxf, MAX_RX_QS);
+	if (num_act_queues)
+		budget_per_q = budget/num_act_queues;
+
+	for_each_set_bit(i, &gfarwgrp->rx_bit_map, priv->num_rx_queues) {
+		/* skip queue if not active */
+		if (!(rstat_rxf & (RSTAT_CLEAR_RXF0 >> i)))
+			continue;
+
+		rx_queue = priv->rx_queue[i];
+		work_done_per_q =
+			gfarw_clean_rx_ring_work(rx_queue, budget_per_q);
+		work_done += work_done_per_q;
+
+		/* finished processing this queue */
+		if (work_done_per_q < budget_per_q) {
+			/* clear active queue hw indication */
+			gfarw_write(&regs->rstat,
+				   RSTAT_CLEAR_RXF0 >> i);
+			num_act_queues--;
+
+			if (!num_act_queues)
+				break;
+		}
+	}
+
+	if (!num_act_queues) {
+		u32 imask;
+		napi_complete(napi);
+
+		/* Clear the halt bit in RSTAT */
+		gfarw_write(&regs->rstat, gfarwgrp->rstat);
+
+		spin_lock_irq(&gfarwgrp->grplock);
+		imask = gfarw_read(&regs->imask);
+		imask |= IMASK_RX_DEFAULT;
+		gfarw_write(&regs->imask, imask);
+		spin_unlock_irq(&gfarwgrp->grplock);
+	}
+
+	return work_done;
+}
+
+static int gfarw_poll_tx(struct napi_struct *napi, int budget)
+{
+	struct gfarw_priv_grp *gfarwgrp =
+		container_of(napi, struct gfarw_priv_grp, napi_tx);
+	struct gfarw_private *priv = gfarwgrp->priv;
+	struct gfarw __iomem *regs = gfarwgrp->regs;
+	struct gfarw_priv_tx_q *tx_queue = NULL;
+	int has_tx_work = 0;
+	int i;
+
+	/* Clear IEVENT, so interrupts aren't called again
+	 * because of the packets that have already arrived
+	 */
+	gfarw_write(&regs->ievent, IEVENT_TX_MASK);
+
+	for_each_set_bit(i, &gfarwgrp->tx_bit_map, priv->num_tx_queues) {
+		tx_queue = priv->tx_queue[i];
+		/* run Tx cleanup to completion */
+		if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx]) {
+			gfarw_clean_tx_ring(tx_queue);
+			has_tx_work = 1;
+		}
+	}
+
+	if (!has_tx_work) {
+		u32 imask;
+		napi_complete(napi);
+
+		spin_lock_irq(&gfarwgrp->grplock);
+		imask = gfarw_read(&regs->imask);
+		imask |= IMASK_TX_DEFAULT;
+		gfarw_write(&regs->imask, imask);
+		spin_unlock_irq(&gfarwgrp->grplock);
+	}
+
+	return 0;
+}
+
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/* Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void gfarw_netpoll(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	int i;
+
+	/* If the device has multiple interrupts, run tx/rx */
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+		for (i = 0; i < priv->num_grps; i++) {
+			struct gfarw_priv_grp *grp = &priv->gfarwgrp[i];
+
+			disable_irq(gfarw_irq(grp, TX)->irq);
+			disable_irq(gfarw_irq(grp, RX)->irq);
+			disable_irq(gfarw_irq(grp, ER)->irq);
+			gfarw_interrupt(gfarw_irq(grp, TX)->irq, grp);
+			enable_irq(gfarw_irq(grp, ER)->irq);
+			enable_irq(gfarw_irq(grp, RX)->irq);
+			enable_irq(gfarw_irq(grp, TX)->irq);
+		}
+	} else {
+		for (i = 0; i < priv->num_grps; i++) {
+			struct gfarw_priv_grp *grp = &priv->gfarwgrp[i];
+
+			disable_irq(gfarw_irq(grp, TX)->irq);
+			gfarw_interrupt(gfarw_irq(grp, TX)->irq, grp);
+			enable_irq(gfarw_irq(grp, TX)->irq);
+		}
+	}
+}
+#endif
+
+/* The interrupt handler for devices with one interrupt */
+static irqreturn_t gfarw_interrupt(int irq, void *grp_id)
+{
+	struct gfarw_priv_grp *gfarwgrp = grp_id;
+
+	/* Save ievent for future reference */
+	u32 events = gfarw_read(&gfarwgrp->regs->ievent);
+
+	/* Check for reception */
+	if (events & IEVENT_RX_MASK)
+		gfarw_receive(irq, grp_id);
+
+	/* Check for transmit completion */
+	if (events & IEVENT_TX_MASK)
+		gfarw_transmit(irq, grp_id);
+
+	/* Check for errors */
+	if (events & IEVENT_ERR_MASK)
+		gfarw_error(irq, grp_id);
+
+	return IRQ_HANDLED;
+}
+
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void adjust_link(struct net_device *dev)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = priv->phydev;
+
+	if (unlikely(phydev->link != priv->oldlink ||
+		     (phydev->link && (phydev->duplex != priv->oldduplex ||
+				       phydev->speed != priv->oldspeed))))
+		gfarw_update_link_state(priv);
+}
+
+/* Update the hash table based on the current list of multicast
+ * addresses we subscribe to.  Also, change the promiscuity of
+ * the device based on the flags (this function is called
+ * whenever dev->flags is changed
+ */
+static void gfarw_set_multi(struct net_device *dev)
+{
+	struct netdev_hw_addr *ha;
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+
+	if (dev->flags & IFF_PROMISC) {
+		/* Set RCTRL to PROM */
+		tempval = gfarw_read(&regs->rctrl);
+		tempval |= RCTRL_PROM;
+		gfarw_write(&regs->rctrl, tempval);
+	} else {
+		/* Set RCTRL to not PROM */
+		tempval = gfarw_read(&regs->rctrl);
+		tempval &= ~(RCTRL_PROM);
+		gfarw_write(&regs->rctrl, tempval);
+	}
+
+	if (dev->flags & IFF_ALLMULTI) {
+		/* Set the hash to rx all multicast frames */
+		gfarw_write(&regs->igaddr0, 0xffffffff);
+		gfarw_write(&regs->igaddr1, 0xffffffff);
+		gfarw_write(&regs->igaddr2, 0xffffffff);
+		gfarw_write(&regs->igaddr3, 0xffffffff);
+		gfarw_write(&regs->igaddr4, 0xffffffff);
+		gfarw_write(&regs->igaddr5, 0xffffffff);
+		gfarw_write(&regs->igaddr6, 0xffffffff);
+		gfarw_write(&regs->igaddr7, 0xffffffff);
+		gfarw_write(&regs->gaddr0, 0xffffffff);
+		gfarw_write(&regs->gaddr1, 0xffffffff);
+		gfarw_write(&regs->gaddr2, 0xffffffff);
+		gfarw_write(&regs->gaddr3, 0xffffffff);
+		gfarw_write(&regs->gaddr4, 0xffffffff);
+		gfarw_write(&regs->gaddr5, 0xffffffff);
+		gfarw_write(&regs->gaddr6, 0xffffffff);
+		gfarw_write(&regs->gaddr7, 0xffffffff);
+	} else {
+		int em_num;
+		int idx;
+
+		/* zero out the hash */
+		gfarw_write(&regs->igaddr0, 0x0);
+		gfarw_write(&regs->igaddr1, 0x0);
+		gfarw_write(&regs->igaddr2, 0x0);
+		gfarw_write(&regs->igaddr3, 0x0);
+		gfarw_write(&regs->igaddr4, 0x0);
+		gfarw_write(&regs->igaddr5, 0x0);
+		gfarw_write(&regs->igaddr6, 0x0);
+		gfarw_write(&regs->igaddr7, 0x0);
+		gfarw_write(&regs->gaddr0, 0x0);
+		gfarw_write(&regs->gaddr1, 0x0);
+		gfarw_write(&regs->gaddr2, 0x0);
+		gfarw_write(&regs->gaddr3, 0x0);
+		gfarw_write(&regs->gaddr4, 0x0);
+		gfarw_write(&regs->gaddr5, 0x0);
+		gfarw_write(&regs->gaddr6, 0x0);
+		gfarw_write(&regs->gaddr7, 0x0);
+
+		/* If we have extended hash tables, we need to
+		 * clear the exact match registers to prepare for
+		 * setting them
+		 */
+		if (priv->extended_hash) {
+			em_num = GFAR_EM_NUM + 1;
+			gfarw_clear_exact_match(dev);
+			idx = 1;
+		} else {
+			idx = 0;
+			em_num = 0;
+		}
+
+		if (netdev_mc_empty(dev))
+			return;
+
+		/* Parse the list, and set the appropriate bits */
+		netdev_for_each_mc_addr(ha, dev) {
+			if (idx < em_num) {
+				gfarw_set_mac_for_addr(dev, idx, ha->addr);
+				idx++;
+			} else
+				gfarw_set_hash_for_addr(dev, ha->addr);
+		}
+	}
+}
+
+
+/* Clears each of the exact match registers to zero, so they
+ * don't interfere with normal reception
+ */
+static void gfarw_clear_exact_match(struct net_device *dev)
+{
+	int idx;
+	static const u8 zero_arr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
+
+	for (idx = 1; idx < GFAR_EM_NUM + 1; idx++)
+		gfarw_set_mac_for_addr(dev, idx, zero_arr);
+}
+
+/* Set the appropriate hash bit for the given addr */
+/* The algorithm works like so:
+ * 1) Take the Destination Address (ie the multicast address), and
+ * do a CRC on it (little endian), and reverse the bits of the
+ * result.
+ * 2) Use the 8 most significant bits as a hash into a 256-entry
+ * table.  The table is controlled through 8 32-bit registers:
+ * gaddr0-7.  gaddr0's MSB is entry 0, and gaddr7's LSB is
+ * gaddr7.  This means that the 3 most significant bits in the
+ * hash index which gaddr register to use, and the 5 other bits
+ * indicate which bit (assuming an IBM numbering scheme, which
+ * for PowerPC (tm) is usually the case) in the register holds
+ * the entry.
+ */
+static void gfarw_set_hash_for_addr(struct net_device *dev, u8 *addr)
+{
+	u32 tempval;
+	struct gfarw_private *priv = netdev_priv(dev);
+	u32 result = ether_crc(ETH_ALEN, addr);
+	int width = priv->hash_width;
+	u8 whichbit = (result >> (32 - width)) & 0x1f;
+	u8 whichreg = result >> (32 - width + 5);
+	u32 value = (1 << (31-whichbit));
+
+	tempval = gfarw_read(priv->hash_regs[whichreg]);
+	tempval |= value;
+	gfarw_write(priv->hash_regs[whichreg], tempval);
+}
+
+
+/* There are multiple MAC Address register pairs on some controllers
+ * This function sets the numth pair to a given address
+ */
+static void gfarw_set_mac_for_addr(struct net_device *dev, int num,
+				  const u8 *addr)
+{
+	struct gfarw_private *priv = netdev_priv(dev);
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 tempval;
+	u32 __iomem *macptr = &regs->macstnaddr1;
+
+	macptr += num*2;
+
+	/* For a station address of 0x12345678ABCD in transmission
+	 * order (BE), MACnADDR1 is set to 0xCDAB7856 and
+	 * MACnADDR2 is set to 0x34120000.
+	 */
+	tempval = (addr[5] << 24) | (addr[4] << 16) |
+		  (addr[3] << 8)  |  addr[2];
+
+	gfarw_write(macptr, tempval);
+
+	tempval = (addr[1] << 24) | (addr[0] << 16);
+
+	gfarw_write(macptr+1, tempval);
+}
+
+/* GFAR error interrupt handler */
+static irqreturn_t gfarw_error(int irq, void *grp_id)
+{
+	struct gfarw_priv_grp *gfarwgrp = grp_id;
+	struct gfarw __iomem *regs = gfarwgrp->regs;
+	struct gfarw_private *priv= gfarwgrp->priv;
+	struct net_device *dev = priv->ndev;
+
+	/* Save ievent for future reference */
+	u32 events = gfarw_read(&regs->ievent);
+
+	/* Clear IEVENT */
+	gfarw_write(&regs->ievent, events & IEVENT_ERR_MASK);
+
+	/* Magic Packet is not an error. */
+	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET) &&
+	    (events & IEVENT_MAG))
+		events &= ~IEVENT_MAG;
+
+	/* Hmm... */
+	if (netif_msg_rx_err(priv) || netif_msg_tx_err(priv))
+		netdev_dbg(dev,
+			   "error interrupt (ievent=0x%08x imask=0x%08x)\n",
+			   events, gfarw_read(&regs->imask));
+
+	/* Update the error counters */
+	if (events & IEVENT_TXE) {
+		dev->stats.tx_errors++;
+
+		if (events & IEVENT_LC)
+			dev->stats.tx_window_errors++;
+		if (events & IEVENT_CRL)
+			dev->stats.tx_aborted_errors++;
+		if (events & IEVENT_XFUN) {
+			netif_dbg(priv, tx_err, dev,
+				  "TX FIFO underrun, packet dropped\n");
+			dev->stats.tx_dropped++;
+			atomic64_inc(&priv->extra_stats.tx_underrun);
+
+			schedule_work(&priv->reset_task);
+		}
+		netif_dbg(priv, tx_err, dev, "Transmit Error\n");
+	}
+	if (events & IEVENT_BSY) {
+		dev->stats.rx_errors++;
+		atomic64_inc(&priv->extra_stats.rx_bsy);
+
+		gfarw_receive(irq, grp_id);
+
+		netif_dbg(priv, rx_err, dev, "busy error (rstat: %x)\n",
+			  gfarw_read(&regs->rstat));
+	}
+	if (events & IEVENT_BABR) {
+		dev->stats.rx_errors++;
+		atomic64_inc(&priv->extra_stats.rx_babr);
+
+		netif_dbg(priv, rx_err, dev, "babbling RX error\n");
+	}
+	if (events & IEVENT_EBERR) {
+		atomic64_inc(&priv->extra_stats.eberr);
+		netif_dbg(priv, rx_err, dev, "bus error\n");
+	}
+	if (events & IEVENT_RXC)
+		netif_dbg(priv, rx_status, dev, "control frame\n");
+
+	if (events & IEVENT_BABT) {
+		atomic64_inc(&priv->extra_stats.tx_babt);
+		netif_dbg(priv, tx_err, dev, "babbling TX error\n");
+	}
+	return IRQ_HANDLED;
+}
+
+static u32 gfarw_get_flowctrl_cfg(struct gfarw_private *priv)
+{
+	struct phy_device *phydev = priv->phydev;
+	u32 val = 0;
+
+	if (!phydev->duplex)
+		return val;
+
+	if (!priv->pause_aneg_en) {
+		if (priv->tx_pause_en)
+			val |= MACCFG1_TX_FLOW;
+		if (priv->rx_pause_en)
+			val |= MACCFG1_RX_FLOW;
+	} else {
+		u16 lcl_adv, rmt_adv;
+		u8 flowctrl;
+		/* get link partner capabilities */
+		rmt_adv = 0;
+		if (phydev->pause)
+			rmt_adv = LPA_PAUSE_CAP;
+		if (phydev->asym_pause)
+			rmt_adv |= LPA_PAUSE_ASYM;
+
+		lcl_adv = 0;
+		if (phydev->advertising & ADVERTISED_Pause)
+			lcl_adv |= ADVERTISE_PAUSE_CAP;
+		if (phydev->advertising & ADVERTISED_Asym_Pause)
+			lcl_adv |= ADVERTISE_PAUSE_ASYM;
+
+		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
+		if (flowctrl & FLOW_CTRL_TX)
+			val |= MACCFG1_TX_FLOW;
+		if (flowctrl & FLOW_CTRL_RX)
+			val |= MACCFG1_RX_FLOW;
+	}
+
+	return val;
+}
+
+static noinline void gfarw_update_link_state(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	struct phy_device *phydev = priv->phydev;
+	struct gfarw_priv_rx_q *rx_queue = NULL;
+	int i;
+	struct rxbd8 *bdp;
+
+	if (unlikely(test_bit(GFAR_RESETTING, &priv->state)))
+		return;
+
+	if (phydev->link) {
+		u32 tempval1 = gfarw_read(&regs->maccfg1);
+		u32 tempval = gfarw_read(&regs->maccfg2);
+		u32 ecntrl = gfarw_read(&regs->ecntrl);
+		u32 tx_flow_oldval = (tempval & MACCFG1_TX_FLOW);
+
+		if (phydev->duplex != priv->oldduplex) {
+			if (!(phydev->duplex))
+				tempval &= ~(MACCFG2_FULL_DUPLEX);
+			else
+				tempval |= MACCFG2_FULL_DUPLEX;
+
+			priv->oldduplex = phydev->duplex;
+		}
+
+		if (phydev->speed != priv->oldspeed) {
+			switch (phydev->speed) {
+			case 1000:
+				tempval =
+				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_GMII);
+
+				ecntrl &= ~(ECNTRL_R100);
+				break;
+			case 100:
+			case 10:
+				tempval =
+				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_MII);
+
+				/* Reduced mode distinguishes
+				 * between 10 and 100
+				 */
+				if (phydev->speed == SPEED_100)
+					ecntrl |= ECNTRL_R100;
+				else
+					ecntrl &= ~(ECNTRL_R100);
+				break;
+			default:
+				netif_warn(priv, link, priv->ndev,
+					   "Ack!  Speed (%d) is not 10/100/1000!\n",
+					   phydev->speed);
+				break;
+			}
+
+			priv->oldspeed = phydev->speed;
+		}
+
+		tempval1 &= ~(MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
+		tempval1 |= gfarw_get_flowctrl_cfg(priv);
+
+		/* Turn last free buffer recording on */
+		if ((tempval1 & MACCFG1_TX_FLOW) && !tx_flow_oldval) {
+			for (i = 0; i < priv->num_rx_queues; i++) {
+				rx_queue = priv->rx_queue[i];
+				bdp = rx_queue->cur_rx;
+				/* skip to previous bd */
+				bdp = skip_bd(bdp, RX_RING_SIZE - 1, rx_queue->rx_bd_base, RX_RING_SIZE);
+
+				if (rx_queue->rfbptr)
+					gfarw_write(rx_queue->rfbptr, (u32)bdp);
+			}
+
+			priv->tx_actual_en = 1;
+		}
+
+		if (unlikely(!(tempval1 & MACCFG1_TX_FLOW) && tx_flow_oldval))
+			priv->tx_actual_en = 0;
+
+		gfarw_write(&regs->maccfg1, tempval1);
+		gfarw_write(&regs->maccfg2, tempval);
+		gfarw_write(&regs->ecntrl, ecntrl);
+
+		if (!priv->oldlink)
+			priv->oldlink = 1;
+
+	} else if (priv->oldlink) {
+		priv->oldlink = 0;
+		priv->oldspeed = 0;
+		priv->oldduplex = -1;
+	}
+
+	if (netif_msg_link(priv))
+		phy_print_status(phydev);
+}
+
+static const struct of_device_id gfarw_match[] =
+{
+	{
+		.type = "network",
+		.compatible = "gianfar-work",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, gfarw_match);
+
+/* Structure for a device driver */
+static struct platform_driver gfarw_driver = {
+	.driver = {
+		.name = "fsl-gianfar-work",
+		.pm = GFAR_PM_OPS,
+		.of_match_table = gfarw_match,
+	},
+	.probe = gfarw_probe,
+	.remove = gfarw_remove,
+};
+
+module_platform_driver(gfarw_driver);
diff --git a/drivers/net/ethernet/freescale/gianfar_work.h b/drivers/net/ethernet/freescale/gianfar_work.h
new file mode 100644
index 000000000000..035cd2a0df9d
--- /dev/null
+++ b/drivers/net/ethernet/freescale/gianfar_work.h
@@ -0,0 +1,1360 @@
+/*
+ * drivers/net/ethernet/freescale/gianfar.h
+ *
+ * Gianfar Ethernet Driver
+ * Driver for FEC on MPC8540 and TSEC on MPC8540/MPC8560
+ * Based on 8260_io/fcc_enet.c
+ *
+ * Author: Andy Fleming
+ * Maintainer: Kumar Gala
+ * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
+ *
+ * Copyright 2002-2009, 2011-2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *  Still left to do:
+ *      -Add support for module parameters
+ *	-Add patch for ethtool phys id
+ */
+#ifndef __GIANFAR_H
+#define __GIANFAR_H
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <linux/crc32.h>
+#include <linux/workqueue.h>
+#include <linux/ethtool.h>
+
+struct ethtool_flow_spec_container {
+	struct ethtool_rx_flow_spec fs;
+	struct list_head list;
+};
+
+struct ethtool_rx_list {
+	struct list_head list;
+	unsigned int count;
+};
+
+/* The maximum number of packets to be handled in one call of gfarw_poll */
+#define GFAR_DEV_WEIGHT 64
+
+/* Length for FCB */
+#define GMAC_FCB_LEN 8
+
+/* Length for TxPAL */
+#define GMAC_TXPAL_LEN 16
+
+/* Default padding amount */
+#define DEFAULT_PADDING 2
+
+/* Number of bytes to align the rx bufs to */
+#define RXBUF_ALIGNMENT 64
+
+/* The number of bytes which composes a unit for the purpose of
+ * allocating data buffers.  ie-for any given MTU, the data buffer
+ * will be the next highest multiple of 512 bytes. */
+#define INCREMENTAL_BUFFER_SIZE 512
+
+#define PHY_INIT_TIMEOUT 100000
+
+#define DRV_NAME "gfarw-enet"
+extern const char gfarw_driver_version[];
+
+/* MAXIMUM NUMBER OF QUEUES SUPPORTED */
+#define MAX_TX_QS	0x8
+#define MAX_RX_QS	0x8
+
+/* MAXIMUM NUMBER OF GROUPS SUPPORTED */
+#define MAXGROUPS 0x2
+
+/* These need to be powers of 2 for this driver */
+#define DEFAULT_TX_RING_SIZE	256
+#define DEFAULT_RX_RING_SIZE	256
+
+#define GFAR_RX_MAX_RING_SIZE   256
+#define GFAR_TX_MAX_RING_SIZE   256
+
+#define GFAR_MAX_FIFO_THRESHOLD 511
+#define GFAR_MAX_FIFO_STARVE	511
+#define GFAR_MAX_FIFO_STARVE_OFF 511
+
+#define FBTHR_SHIFT        24
+#define DEFAULT_RX_LFC_THR  16
+#define DEFAULT_LFC_PTVVAL  4
+
+#define DEFAULT_RX_BUFFER_SIZE  1536
+#define TX_RING_MOD_MASK(size) (size-1)
+#define RX_RING_MOD_MASK(size) (size-1)
+#define JUMBO_BUFFER_SIZE 9728
+#define JUMBO_FRAME_SIZE 9600
+
+#define DEFAULT_FIFO_TX_THR 0x100
+#define DEFAULT_FIFO_TX_STARVE 0x40
+#define DEFAULT_FIFO_TX_STARVE_OFF 0x80
+#define DEFAULT_BD_STASH 1
+#define DEFAULT_STASH_LENGTH	96
+#define DEFAULT_STASH_INDEX	0
+
+/* The number of Exact Match registers */
+#define GFAR_EM_NUM	15
+
+/* Latency of interface clock in nanoseconds */
+/* Interface clock latency , in this case, means the
+ * time described by a value of 1 in the interrupt
+ * coalescing registers' time fields.  Since those fields
+ * refer to the time it takes for 64 clocks to pass, the
+ * latencies are as such:
+ * GBIT = 125MHz => 8ns/clock => 8*64 ns / tick
+ * 100 = 25 MHz => 40ns/clock => 40*64 ns / tick
+ * 10 = 2.5 MHz => 400ns/clock => 400*64 ns / tick
+ */
+#define GFAR_GBIT_TIME  512
+#define GFAR_100_TIME   2560
+#define GFAR_10_TIME    25600
+
+#define DEFAULT_TX_COALESCE 1
+#define DEFAULT_TXCOUNT	16
+#define DEFAULT_TXTIME	21
+
+#define DEFAULT_RXTIME	21
+
+#define DEFAULT_RX_COALESCE 0
+#define DEFAULT_RXCOUNT	0
+
+#define GFAR_SUPPORTED (SUPPORTED_10baseT_Half \
+		| SUPPORTED_10baseT_Full \
+		| SUPPORTED_100baseT_Half \
+		| SUPPORTED_100baseT_Full \
+		| SUPPORTED_Autoneg \
+		| SUPPORTED_MII)
+
+#define GFAR_SUPPORTED_GBIT SUPPORTED_1000baseT_Full
+
+/* TBI register addresses */
+#define MII_TBICON		0x11
+
+/* TBICON register bit fields */
+#define TBICON_CLK_SELECT	0x0020
+
+/* MAC register bits */
+#define MACCFG1_SOFT_RESET	0x80000000
+#define MACCFG1_RESET_RX_MC	0x00080000
+#define MACCFG1_RESET_TX_MC	0x00040000
+#define MACCFG1_RESET_RX_FUN	0x00020000
+#define	MACCFG1_RESET_TX_FUN	0x00010000
+#define MACCFG1_LOOPBACK	0x00000100
+#define MACCFG1_RX_FLOW		0x00000020
+#define MACCFG1_TX_FLOW		0x00000010
+#define MACCFG1_SYNCD_RX_EN	0x00000008
+#define MACCFG1_RX_EN		0x00000004
+#define MACCFG1_SYNCD_TX_EN	0x00000002
+#define MACCFG1_TX_EN		0x00000001
+
+#define MACCFG2_INIT_SETTINGS	0x00007205
+#define MACCFG2_FULL_DUPLEX	0x00000001
+#define MACCFG2_IF              0x00000300
+#define MACCFG2_MII             0x00000100
+#define MACCFG2_GMII            0x00000200
+#define MACCFG2_HUGEFRAME	0x00000020
+#define MACCFG2_LENGTHCHECK	0x00000010
+#define MACCFG2_MPEN		0x00000008
+
+#define ECNTRL_FIFM		0x00008000
+#define ECNTRL_INIT_SETTINGS	0x00001000
+#define ECNTRL_TBI_MODE         0x00000020
+#define ECNTRL_REDUCED_MODE	0x00000010
+#define ECNTRL_R100		0x00000008
+#define ECNTRL_REDUCED_MII_MODE	0x00000004
+#define ECNTRL_SGMII_MODE	0x00000002
+
+#define MRBLR_INIT_SETTINGS	DEFAULT_RX_BUFFER_SIZE
+
+#define MINFLR_INIT_SETTINGS	0x00000040
+
+/* Tqueue control */
+#define TQUEUE_EN0		0x00008000
+#define TQUEUE_EN1		0x00004000
+#define TQUEUE_EN2		0x00002000
+#define TQUEUE_EN3		0x00001000
+#define TQUEUE_EN4		0x00000800
+#define TQUEUE_EN5		0x00000400
+#define TQUEUE_EN6		0x00000200
+#define TQUEUE_EN7		0x00000100
+#define TQUEUE_EN_ALL		0x0000FF00
+
+#define TR03WT_WT0_MASK		0xFF000000
+#define TR03WT_WT1_MASK		0x00FF0000
+#define TR03WT_WT2_MASK		0x0000FF00
+#define TR03WT_WT3_MASK		0x000000FF
+
+#define TR47WT_WT4_MASK		0xFF000000
+#define TR47WT_WT5_MASK		0x00FF0000
+#define TR47WT_WT6_MASK		0x0000FF00
+#define TR47WT_WT7_MASK		0x000000FF
+
+/* Rqueue control */
+#define RQUEUE_EX0		0x00800000
+#define RQUEUE_EX1		0x00400000
+#define RQUEUE_EX2		0x00200000
+#define RQUEUE_EX3		0x00100000
+#define RQUEUE_EX4		0x00080000
+#define RQUEUE_EX5		0x00040000
+#define RQUEUE_EX6		0x00020000
+#define RQUEUE_EX7		0x00010000
+#define RQUEUE_EX_ALL		0x00FF0000
+
+#define RQUEUE_EN0		0x00000080
+#define RQUEUE_EN1		0x00000040
+#define RQUEUE_EN2		0x00000020
+#define RQUEUE_EN3		0x00000010
+#define RQUEUE_EN4		0x00000008
+#define RQUEUE_EN5		0x00000004
+#define RQUEUE_EN6		0x00000002
+#define RQUEUE_EN7		0x00000001
+#define RQUEUE_EN_ALL		0x000000FF
+
+/* Init to do tx snooping for buffers and descriptors */
+#define DMACTRL_INIT_SETTINGS   0x000000c3
+#define DMACTRL_GRS             0x00000010
+#define DMACTRL_GTS             0x00000008
+
+#define TSTAT_CLEAR_THALT_ALL	0xFF000000
+#define TSTAT_CLEAR_THALT	0x80000000
+#define TSTAT_CLEAR_THALT0	0x80000000
+#define TSTAT_CLEAR_THALT1	0x40000000
+#define TSTAT_CLEAR_THALT2	0x20000000
+#define TSTAT_CLEAR_THALT3	0x10000000
+#define TSTAT_CLEAR_THALT4	0x08000000
+#define TSTAT_CLEAR_THALT5	0x04000000
+#define TSTAT_CLEAR_THALT6	0x02000000
+#define TSTAT_CLEAR_THALT7	0x01000000
+
+/* Interrupt coalescing macros */
+#define IC_ICEN			0x80000000
+#define IC_ICFT_MASK		0x1fe00000
+#define IC_ICFT_SHIFT		21
+#define mk_ic_icft(x)		\
+	(((unsigned int)x << IC_ICFT_SHIFT)&IC_ICFT_MASK)
+#define IC_ICTT_MASK		0x0000ffff
+#define mk_ic_ictt(x)		(x&IC_ICTT_MASK)
+
+#define mk_ic_value(count, time) (IC_ICEN | \
+				mk_ic_icft(count) | \
+				mk_ic_ictt(time))
+#define get_icft_value(ic)	(((unsigned long)ic & IC_ICFT_MASK) >> \
+				 IC_ICFT_SHIFT)
+#define get_ictt_value(ic)	((unsigned long)ic & IC_ICTT_MASK)
+
+#define DEFAULT_TXIC mk_ic_value(DEFAULT_TXCOUNT, DEFAULT_TXTIME)
+#define DEFAULT_RXIC mk_ic_value(DEFAULT_RXCOUNT, DEFAULT_RXTIME)
+
+#define skip_bd(bdp, stride, base, ring_size) ({ \
+	typeof(bdp) new_bd = (bdp) + (stride); \
+	(new_bd >= (base) + (ring_size)) ? (new_bd - (ring_size)) : new_bd; })
+
+#define next_bd(bdp, base, ring_size) skip_bd(bdp, 1, base, ring_size)
+
+#define RCTRL_TS_ENABLE 	0x01000000
+#define RCTRL_PAL_MASK		0x001f0000
+#define RCTRL_LFC		0x00004000
+#define RCTRL_VLEX		0x00002000
+#define RCTRL_FILREN		0x00001000
+#define RCTRL_GHTX		0x00000400
+#define RCTRL_IPCSEN		0x00000200
+#define RCTRL_TUCSEN		0x00000100
+#define RCTRL_PRSDEP_MASK	0x000000c0
+#define RCTRL_PRSDEP_INIT	0x000000c0
+#define RCTRL_PRSFM		0x00000020
+#define RCTRL_PROM		0x00000008
+#define RCTRL_EMEN		0x00000002
+#define RCTRL_REQ_PARSER	(RCTRL_VLEX | RCTRL_IPCSEN | \
+				 RCTRL_TUCSEN | RCTRL_FILREN)
+#define RCTRL_CHECKSUMMING	(RCTRL_IPCSEN | RCTRL_TUCSEN | \
+				RCTRL_PRSDEP_INIT)
+#define RCTRL_EXTHASH		(RCTRL_GHTX)
+#define RCTRL_VLAN		(RCTRL_PRSDEP_INIT)
+#define RCTRL_PADDING(x)	((x << 16) & RCTRL_PAL_MASK)
+
+
+#define RSTAT_CLEAR_RHALT	0x00800000
+#define RSTAT_CLEAR_RXF0	0x00000080
+#define RSTAT_RXF_MASK		0x000000ff
+
+#define TCTRL_IPCSEN		0x00004000
+#define TCTRL_TUCSEN		0x00002000
+#define TCTRL_VLINS		0x00001000
+#define TCTRL_THDF		0x00000800
+#define TCTRL_RFCPAUSE		0x00000010
+#define TCTRL_TFCPAUSE		0x00000008
+#define TCTRL_TXSCHED_MASK	0x00000006
+#define TCTRL_TXSCHED_INIT	0x00000000
+/* priority scheduling */
+#define TCTRL_TXSCHED_PRIO	0x00000002
+/* weighted round-robin scheduling (WRRS) */
+#define TCTRL_TXSCHED_WRRS	0x00000004
+/* default WRRS weight and policy setting,
+ * tailored to the tr03wt and tr47wt registers:
+ * equal weight for all Tx Qs, measured in 64byte units
+ */
+#define DEFAULT_WRRS_WEIGHT	0x18181818
+
+#define TCTRL_INIT_CSUM		(TCTRL_TUCSEN | TCTRL_IPCSEN)
+
+#define IEVENT_INIT_CLEAR	0xffffffff
+#define IEVENT_BABR		0x80000000
+#define IEVENT_RXC		0x40000000
+#define IEVENT_BSY		0x20000000
+#define IEVENT_EBERR		0x10000000
+#define IEVENT_MSRO		0x04000000
+#define IEVENT_GTSC		0x02000000
+#define IEVENT_BABT		0x01000000
+#define IEVENT_TXC		0x00800000
+#define IEVENT_TXE		0x00400000
+#define IEVENT_TXB		0x00200000
+#define IEVENT_TXF		0x00100000
+#define IEVENT_LC		0x00040000
+#define IEVENT_CRL		0x00020000
+#define IEVENT_XFUN		0x00010000
+#define IEVENT_RXB0		0x00008000
+#define IEVENT_MAG		0x00000800
+#define IEVENT_GRSC		0x00000100
+#define IEVENT_RXF0		0x00000080
+#define IEVENT_FIR		0x00000008
+#define IEVENT_FIQ		0x00000004
+#define IEVENT_DPE		0x00000002
+#define IEVENT_PERR		0x00000001
+#define IEVENT_RX_MASK          (IEVENT_RXB0 | IEVENT_RXF0 | IEVENT_BSY)
+#define IEVENT_TX_MASK          (IEVENT_TXB | IEVENT_TXF)
+#define IEVENT_RTX_MASK         (IEVENT_RX_MASK | IEVENT_TX_MASK)
+#define IEVENT_ERR_MASK         \
+(IEVENT_RXC | IEVENT_BSY | IEVENT_EBERR | IEVENT_MSRO | \
+ IEVENT_BABT | IEVENT_TXC | IEVENT_TXE | IEVENT_LC \
+ | IEVENT_CRL | IEVENT_XFUN | IEVENT_DPE | IEVENT_PERR \
+ | IEVENT_MAG | IEVENT_BABR)
+
+#define IMASK_INIT_CLEAR	0x00000000
+#define IMASK_BABR              0x80000000
+#define IMASK_RXC               0x40000000
+#define IMASK_BSY               0x20000000
+#define IMASK_EBERR             0x10000000
+#define IMASK_MSRO		0x04000000
+#define IMASK_GTSC              0x02000000
+#define IMASK_BABT		0x01000000
+#define IMASK_TXC               0x00800000
+#define IMASK_TXEEN		0x00400000
+#define IMASK_TXBEN		0x00200000
+#define IMASK_TXFEN             0x00100000
+#define IMASK_LC		0x00040000
+#define IMASK_CRL		0x00020000
+#define IMASK_XFUN		0x00010000
+#define IMASK_RXB0              0x00008000
+#define IMASK_MAG		0x00000800
+#define IMASK_GRSC              0x00000100
+#define IMASK_RXFEN0		0x00000080
+#define IMASK_FIR		0x00000008
+#define IMASK_FIQ		0x00000004
+#define IMASK_DPE		0x00000002
+#define IMASK_PERR		0x00000001
+#define IMASK_DEFAULT  (IMASK_TXEEN | IMASK_TXFEN | IMASK_TXBEN | \
+		IMASK_RXFEN0 | IMASK_BSY | IMASK_EBERR | IMASK_BABR | \
+		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_DPE \
+		| IMASK_PERR)
+#define IMASK_RX_DEFAULT (IMASK_RXFEN0 | IMASK_BSY)
+#define IMASK_TX_DEFAULT (IMASK_TXFEN | IMASK_TXBEN)
+
+#define IMASK_RX_DISABLED ((~(IMASK_RX_DEFAULT)) & IMASK_DEFAULT)
+#define IMASK_TX_DISABLED ((~(IMASK_TX_DEFAULT)) & IMASK_DEFAULT)
+
+/* Fifo management */
+#define FIFO_TX_THR_MASK	0x01ff
+#define FIFO_TX_STARVE_MASK	0x01ff
+#define FIFO_TX_STARVE_OFF_MASK	0x01ff
+
+/* Attribute fields */
+
+/* This enables rx snooping for buffers and descriptors */
+#define ATTR_BDSTASH		0x00000800
+
+#define ATTR_BUFSTASH		0x00004000
+
+#define ATTR_SNOOPING		0x000000c0
+#define ATTR_INIT_SETTINGS      ATTR_SNOOPING
+
+#define ATTRELI_INIT_SETTINGS   0x0
+#define ATTRELI_EL_MASK		0x3fff0000
+#define ATTRELI_EL(x) (x << 16)
+#define ATTRELI_EI_MASK		0x00003fff
+#define ATTRELI_EI(x) (x)
+
+#define BD_LFLAG(flags) ((flags) << 16)
+#define BD_LENGTH_MASK		0x0000ffff
+
+#define FPR_FILER_MASK	0xFFFFFFFF
+#define MAX_FILER_IDX	0xFF
+
+/* This default RIR value directly corresponds
+ * to the 3-bit hash value generated */
+#define DEFAULT_8RXQ_RIR0	0x05397700
+/* Map even hash values to Q0, and odd ones to Q1 */
+#define DEFAULT_2RXQ_RIR0	0x04104100
+
+/* RQFCR register bits */
+#define RQFCR_GPI		0x80000000
+#define RQFCR_HASHTBL_Q		0x00000000
+#define RQFCR_HASHTBL_0		0x00020000
+#define RQFCR_HASHTBL_1		0x00040000
+#define RQFCR_HASHTBL_2		0x00060000
+#define RQFCR_HASHTBL_3		0x00080000
+#define RQFCR_HASH		0x00010000
+#define RQFCR_QUEUE		0x0000FC00
+#define RQFCR_CLE		0x00000200
+#define RQFCR_RJE		0x00000100
+#define RQFCR_AND		0x00000080
+#define RQFCR_CMP_EXACT		0x00000000
+#define RQFCR_CMP_MATCH		0x00000020
+#define RQFCR_CMP_NOEXACT	0x00000040
+#define RQFCR_CMP_NOMATCH	0x00000060
+
+/* RQFCR PID values */
+#define	RQFCR_PID_MASK		0x00000000
+#define	RQFCR_PID_PARSE		0x00000001
+#define	RQFCR_PID_ARB		0x00000002
+#define	RQFCR_PID_DAH		0x00000003
+#define	RQFCR_PID_DAL		0x00000004
+#define	RQFCR_PID_SAH		0x00000005
+#define	RQFCR_PID_SAL		0x00000006
+#define	RQFCR_PID_ETY		0x00000007
+#define	RQFCR_PID_VID		0x00000008
+#define	RQFCR_PID_PRI		0x00000009
+#define	RQFCR_PID_TOS		0x0000000A
+#define	RQFCR_PID_L4P		0x0000000B
+#define	RQFCR_PID_DIA		0x0000000C
+#define	RQFCR_PID_SIA		0x0000000D
+#define	RQFCR_PID_DPT		0x0000000E
+#define	RQFCR_PID_SPT		0x0000000F
+
+/* RQFPR when PID is 0x0001 */
+#define RQFPR_HDR_GE_512	0x00200000
+#define RQFPR_LERR		0x00100000
+#define RQFPR_RAR		0x00080000
+#define RQFPR_RARQ		0x00040000
+#define RQFPR_AR		0x00020000
+#define RQFPR_ARQ		0x00010000
+#define RQFPR_EBC		0x00008000
+#define RQFPR_VLN		0x00004000
+#define RQFPR_CFI		0x00002000
+#define RQFPR_JUM		0x00001000
+#define RQFPR_IPF		0x00000800
+#define RQFPR_FIF		0x00000400
+#define RQFPR_IPV4		0x00000200
+#define RQFPR_IPV6		0x00000100
+#define RQFPR_ICC		0x00000080
+#define RQFPR_ICV		0x00000040
+#define RQFPR_TCP		0x00000020
+#define RQFPR_UDP		0x00000010
+#define RQFPR_TUC		0x00000008
+#define RQFPR_TUV		0x00000004
+#define RQFPR_PER		0x00000002
+#define RQFPR_EER		0x00000001
+
+/* TxBD status field bits */
+#define TXBD_READY		0x8000
+#define TXBD_PADCRC		0x4000
+#define TXBD_WRAP		0x2000
+#define TXBD_INTERRUPT		0x1000
+#define TXBD_LAST		0x0800
+#define TXBD_CRC		0x0400
+#define TXBD_DEF		0x0200
+#define TXBD_HUGEFRAME		0x0080
+#define TXBD_LATECOLLISION	0x0080
+#define TXBD_RETRYLIMIT		0x0040
+#define	TXBD_RETRYCOUNTMASK	0x003c
+#define TXBD_UNDERRUN		0x0002
+#define TXBD_TOE		0x0002
+
+/* Tx FCB param bits */
+#define TXFCB_VLN		0x80
+#define TXFCB_IP		0x40
+#define TXFCB_IP6		0x20
+#define TXFCB_TUP		0x10
+#define TXFCB_UDP		0x08
+#define TXFCB_CIP		0x04
+#define TXFCB_CTU		0x02
+#define TXFCB_NPH		0x01
+#define TXFCB_DEFAULT 		(TXFCB_IP|TXFCB_TUP|TXFCB_CTU|TXFCB_NPH)
+
+/* RxBD status field bits */
+#define RXBD_EMPTY		0x8000
+#define RXBD_RO1		0x4000
+#define RXBD_WRAP		0x2000
+#define RXBD_INTERRUPT		0x1000
+#define RXBD_LAST		0x0800
+#define RXBD_FIRST		0x0400
+#define RXBD_MISS		0x0100
+#define RXBD_BROADCAST		0x0080
+#define RXBD_MULTICAST		0x0040
+#define RXBD_LARGE		0x0020
+#define RXBD_NONOCTET		0x0010
+#define RXBD_SHORT		0x0008
+#define RXBD_CRCERR		0x0004
+#define RXBD_OVERRUN		0x0002
+#define RXBD_TRUNCATED		0x0001
+#define RXBD_STATS		0x01ff
+#define RXBD_ERR		(RXBD_LARGE | RXBD_SHORT | RXBD_NONOCTET 	\
+				| RXBD_CRCERR | RXBD_OVERRUN			\
+				| RXBD_TRUNCATED)
+
+/* Rx FCB status field bits */
+#define RXFCB_VLN		0x8000
+#define RXFCB_IP		0x4000
+#define RXFCB_IP6		0x2000
+#define RXFCB_TUP		0x1000
+#define RXFCB_CIP		0x0800
+#define RXFCB_CTU		0x0400
+#define RXFCB_EIP		0x0200
+#define RXFCB_ETU		0x0100
+#define RXFCB_CSUM_MASK		0x0f00
+#define RXFCB_PERR_MASK		0x000c
+#define RXFCB_PERR_BADL3	0x0008
+
+#define GFAR_INT_NAME_MAX	(IFNAMSIZ + 6)	/* '_g#_xx' */
+
+struct txbd8
+{
+	union {
+		struct {
+			__be16	status;	/* Status Fields */
+			__be16	length;	/* Buffer length */
+		};
+		__be32 lstatus;
+	};
+	__be32	bufPtr;	/* Buffer Pointer */
+};
+
+struct txfcb {
+	u8	flags;
+	u8	ptp;    /* Flag to enable tx timestamping */
+	u8	l4os;	/* Level 4 Header Offset */
+	u8	l3os; 	/* Level 3 Header Offset */
+	__be16	phcs;	/* Pseudo-header Checksum */
+	__be16	vlctl;	/* VLAN control word */
+};
+
+struct rxbd8
+{
+	union {
+		struct {
+			__be16	status;	/* Status Fields */
+			__be16	length;	/* Buffer Length */
+		};
+		__be32 lstatus;
+	};
+	__be32	bufPtr;	/* Buffer Pointer */
+};
+
+struct rxfcb {
+	__be16	flags;
+	u8	rq;	/* Receive Queue index */
+	u8	pro;	/* Layer 4 Protocol */
+	u16	reserved;
+	__be16	vlctl;	/* VLAN control word */
+};
+
+struct gianfar_skb_cb {
+	unsigned int bytes_sent; /* bytes-on-wire (i.e. no FCB) */
+};
+
+#define GFAR_CB(skb) ((struct gianfar_skb_cb *)((skb)->cb))
+
+struct rmon_mib
+{
+	u32	tr64;	/* 0x.680 - Transmit and Receive 64-byte Frame Counter */
+	u32	tr127;	/* 0x.684 - Transmit and Receive 65-127 byte Frame Counter */
+	u32	tr255;	/* 0x.688 - Transmit and Receive 128-255 byte Frame Counter */
+	u32	tr511;	/* 0x.68c - Transmit and Receive 256-511 byte Frame Counter */
+	u32	tr1k;	/* 0x.690 - Transmit and Receive 512-1023 byte Frame Counter */
+	u32	trmax;	/* 0x.694 - Transmit and Receive 1024-1518 byte Frame Counter */
+	u32	trmgv;	/* 0x.698 - Transmit and Receive 1519-1522 byte Good VLAN Frame */
+	u32	rbyt;	/* 0x.69c - Receive Byte Counter */
+	u32	rpkt;	/* 0x.6a0 - Receive Packet Counter */
+	u32	rfcs;	/* 0x.6a4 - Receive FCS Error Counter */
+	u32	rmca;	/* 0x.6a8 - Receive Multicast Packet Counter */
+	u32	rbca;	/* 0x.6ac - Receive Broadcast Packet Counter */
+	u32	rxcf;	/* 0x.6b0 - Receive Control Frame Packet Counter */
+	u32	rxpf;	/* 0x.6b4 - Receive Pause Frame Packet Counter */
+	u32	rxuo;	/* 0x.6b8 - Receive Unknown OP Code Counter */
+	u32	raln;	/* 0x.6bc - Receive Alignment Error Counter */
+	u32	rflr;	/* 0x.6c0 - Receive Frame Length Error Counter */
+	u32	rcde;	/* 0x.6c4 - Receive Code Error Counter */
+	u32	rcse;	/* 0x.6c8 - Receive Carrier Sense Error Counter */
+	u32	rund;	/* 0x.6cc - Receive Undersize Packet Counter */
+	u32	rovr;	/* 0x.6d0 - Receive Oversize Packet Counter */
+	u32	rfrg;	/* 0x.6d4 - Receive Fragments Counter */
+	u32	rjbr;	/* 0x.6d8 - Receive Jabber Counter */
+	u32	rdrp;	/* 0x.6dc - Receive Drop Counter */
+	u32	tbyt;	/* 0x.6e0 - Transmit Byte Counter Counter */
+	u32	tpkt;	/* 0x.6e4 - Transmit Packet Counter */
+	u32	tmca;	/* 0x.6e8 - Transmit Multicast Packet Counter */
+	u32	tbca;	/* 0x.6ec - Transmit Broadcast Packet Counter */
+	u32	txpf;	/* 0x.6f0 - Transmit Pause Control Frame Counter */
+	u32	tdfr;	/* 0x.6f4 - Transmit Deferral Packet Counter */
+	u32	tedf;	/* 0x.6f8 - Transmit Excessive Deferral Packet Counter */
+	u32	tscl;	/* 0x.6fc - Transmit Single Collision Packet Counter */
+	u32	tmcl;	/* 0x.700 - Transmit Multiple Collision Packet Counter */
+	u32	tlcl;	/* 0x.704 - Transmit Late Collision Packet Counter */
+	u32	txcl;	/* 0x.708 - Transmit Excessive Collision Packet Counter */
+	u32	tncl;	/* 0x.70c - Transmit Total Collision Counter */
+	u8	res1[4];
+	u32	tdrp;	/* 0x.714 - Transmit Drop Frame Counter */
+	u32	tjbr;	/* 0x.718 - Transmit Jabber Frame Counter */
+	u32	tfcs;	/* 0x.71c - Transmit FCS Error Counter */
+	u32	txcf;	/* 0x.720 - Transmit Control Frame Counter */
+	u32	tovr;	/* 0x.724 - Transmit Oversize Frame Counter */
+	u32	tund;	/* 0x.728 - Transmit Undersize Frame Counter */
+	u32	tfrg;	/* 0x.72c - Transmit Fragments Frame Counter */
+	u32	car1;	/* 0x.730 - Carry Register One */
+	u32	car2;	/* 0x.734 - Carry Register Two */
+	u32	cam1;	/* 0x.738 - Carry Mask Register One */
+	u32	cam2;	/* 0x.73c - Carry Mask Register Two */
+};
+
+struct gfarw_extra_stats {
+	atomic64_t rx_large;
+	atomic64_t rx_short;
+	atomic64_t rx_nonoctet;
+	atomic64_t rx_crcerr;
+	atomic64_t rx_overrun;
+	atomic64_t rx_bsy;
+	atomic64_t rx_babr;
+	atomic64_t rx_trunc;
+	atomic64_t eberr;
+	atomic64_t tx_babt;
+	atomic64_t tx_underrun;
+	atomic64_t rx_skbmissing;
+	atomic64_t tx_timeout;
+};
+
+#define GFAR_RMON_LEN ((sizeof(struct rmon_mib) - 16)/sizeof(u32))
+#define GFAR_EXTRA_STATS_LEN \
+	(sizeof(struct gfarw_extra_stats)/sizeof(atomic64_t))
+
+/* Number of stats exported via ethtool */
+#define GFAR_STATS_LEN (GFAR_RMON_LEN + GFAR_EXTRA_STATS_LEN)
+
+struct gfarw {
+	u32	tsec_id;	/* 0x.000 - Controller ID register */
+	u32	tsec_id2;	/* 0x.004 - Controller ID2 register */
+	u8	res1[8];
+	u32	ievent;		/* 0x.010 - Interrupt Event Register */
+	u32	imask;		/* 0x.014 - Interrupt Mask Register */
+	u32	edis;		/* 0x.018 - Error Disabled Register */
+	u32	emapg;		/* 0x.01c - Group Error mapping register */
+	u32	ecntrl;		/* 0x.020 - Ethernet Control Register */
+	u32	minflr;		/* 0x.024 - Minimum Frame Length Register */
+	u32	ptv;		/* 0x.028 - Pause Time Value Register */
+	u32	dmactrl;	/* 0x.02c - DMA Control Register */
+	u32	tbipa;		/* 0x.030 - TBI PHY Address Register */
+	u8	res2[28];
+	u32	fifo_rx_pause;	/* 0x.050 - FIFO receive pause start threshold
+					register */
+	u32	fifo_rx_pause_shutoff;	/* x.054 - FIFO receive starve shutoff
+						register */
+	u32	fifo_rx_alarm;	/* 0x.058 - FIFO receive alarm start threshold
+						register */
+	u32	fifo_rx_alarm_shutoff;	/*0x.05c - FIFO receive alarm  starve
+						shutoff register */
+	u8	res3[44];
+	u32	fifo_tx_thr;	/* 0x.08c - FIFO transmit threshold register */
+	u8	res4[8];
+	u32	fifo_tx_starve;	/* 0x.098 - FIFO transmit starve register */
+	u32	fifo_tx_starve_shutoff;	/* 0x.09c - FIFO transmit starve shutoff register */
+	u8	res5[96];
+	u32	tctrl;		/* 0x.100 - Transmit Control Register */
+	u32	tstat;		/* 0x.104 - Transmit Status Register */
+	u32	dfvlan;		/* 0x.108 - Default VLAN Control word */
+	u32	tbdlen;		/* 0x.10c - Transmit Buffer Descriptor Data Length Register */
+	u32	txic;		/* 0x.110 - Transmit Interrupt Coalescing Configuration Register */
+	u32	tqueue;		/* 0x.114 - Transmit queue control register */
+	u8	res7[40];
+	u32	tr03wt;		/* 0x.140 - TxBD Rings 0-3 round-robin weightings */
+	u32	tr47wt;		/* 0x.144 - TxBD Rings 4-7 round-robin weightings */
+	u8	res8[52];
+	u32	tbdbph;		/* 0x.17c - Tx data buffer pointer high */
+	u8	res9a[4];
+	u32	tbptr0;		/* 0x.184 - TxBD Pointer for ring 0 */
+	u8	res9b[4];
+	u32	tbptr1;		/* 0x.18c - TxBD Pointer for ring 1 */
+	u8	res9c[4];
+	u32	tbptr2;		/* 0x.194 - TxBD Pointer for ring 2 */
+	u8	res9d[4];
+	u32	tbptr3;		/* 0x.19c - TxBD Pointer for ring 3 */
+	u8	res9e[4];
+	u32	tbptr4;		/* 0x.1a4 - TxBD Pointer for ring 4 */
+	u8	res9f[4];
+	u32	tbptr5;		/* 0x.1ac - TxBD Pointer for ring 5 */
+	u8	res9g[4];
+	u32	tbptr6;		/* 0x.1b4 - TxBD Pointer for ring 6 */
+	u8	res9h[4];
+	u32	tbptr7;		/* 0x.1bc - TxBD Pointer for ring 7 */
+	u8	res9[64];
+	u32	tbaseh;		/* 0x.200 - TxBD base address high */
+	u32	tbase0;		/* 0x.204 - TxBD Base Address of ring 0 */
+	u8	res10a[4];
+	u32	tbase1;		/* 0x.20c - TxBD Base Address of ring 1 */
+	u8	res10b[4];
+	u32	tbase2;		/* 0x.214 - TxBD Base Address of ring 2 */
+	u8	res10c[4];
+	u32	tbase3;		/* 0x.21c - TxBD Base Address of ring 3 */
+	u8	res10d[4];
+	u32	tbase4;		/* 0x.224 - TxBD Base Address of ring 4 */
+	u8	res10e[4];
+	u32	tbase5;		/* 0x.22c - TxBD Base Address of ring 5 */
+	u8	res10f[4];
+	u32	tbase6;		/* 0x.234 - TxBD Base Address of ring 6 */
+	u8	res10g[4];
+	u32	tbase7;		/* 0x.23c - TxBD Base Address of ring 7 */
+	u8	res10[192];
+	u32	rctrl;		/* 0x.300 - Receive Control Register */
+	u32	rstat;		/* 0x.304 - Receive Status Register */
+	u8	res12[8];
+	u32	rxic;		/* 0x.310 - Receive Interrupt Coalescing Configuration Register */
+	u32	rqueue;		/* 0x.314 - Receive queue control register */
+	u32	rir0;		/* 0x.318 - Ring mapping register 0 */
+	u32	rir1;		/* 0x.31c - Ring mapping register 1 */
+	u32	rir2;		/* 0x.320 - Ring mapping register 2 */
+	u32	rir3;		/* 0x.324 - Ring mapping register 3 */
+	u8	res13[8];
+	u32	rbifx;		/* 0x.330 - Receive bit field extract control register */
+	u32	rqfar;		/* 0x.334 - Receive queue filing table address register */
+	u32	rqfcr;		/* 0x.338 - Receive queue filing table control register */
+	u32	rqfpr;		/* 0x.33c - Receive queue filing table property register */
+	u32	mrblr;		/* 0x.340 - Maximum Receive Buffer Length Register */
+	u8	res14[56];
+	u32	rbdbph;		/* 0x.37c - Rx data buffer pointer high */
+	u8	res15a[4];
+	u32	rbptr0;		/* 0x.384 - RxBD pointer for ring 0 */
+	u8	res15b[4];
+	u32	rbptr1;		/* 0x.38c - RxBD pointer for ring 1 */
+	u8	res15c[4];
+	u32	rbptr2;		/* 0x.394 - RxBD pointer for ring 2 */
+	u8	res15d[4];
+	u32	rbptr3;		/* 0x.39c - RxBD pointer for ring 3 */
+	u8	res15e[4];
+	u32	rbptr4;		/* 0x.3a4 - RxBD pointer for ring 4 */
+	u8	res15f[4];
+	u32	rbptr5;		/* 0x.3ac - RxBD pointer for ring 5 */
+	u8	res15g[4];
+	u32	rbptr6;		/* 0x.3b4 - RxBD pointer for ring 6 */
+	u8	res15h[4];
+	u32	rbptr7;		/* 0x.3bc - RxBD pointer for ring 7 */
+	u8	res16[64];
+	u32	rbaseh;		/* 0x.400 - RxBD base address high */
+	u32	rbase0;		/* 0x.404 - RxBD base address of ring 0 */
+	u8	res17a[4];
+	u32	rbase1;		/* 0x.40c - RxBD base address of ring 1 */
+	u8	res17b[4];
+	u32	rbase2;		/* 0x.414 - RxBD base address of ring 2 */
+	u8	res17c[4];
+	u32	rbase3;		/* 0x.41c - RxBD base address of ring 3 */
+	u8	res17d[4];
+	u32	rbase4;		/* 0x.424 - RxBD base address of ring 4 */
+	u8	res17e[4];
+	u32	rbase5;		/* 0x.42c - RxBD base address of ring 5 */
+	u8	res17f[4];
+	u32	rbase6;		/* 0x.434 - RxBD base address of ring 6 */
+	u8	res17g[4];
+	u32	rbase7;		/* 0x.43c - RxBD base address of ring 7 */
+	u8	res17[192];
+	u32	maccfg1;	/* 0x.500 - MAC Configuration 1 Register */
+	u32	maccfg2;	/* 0x.504 - MAC Configuration 2 Register */
+	u32	ipgifg;		/* 0x.508 - Inter Packet Gap/Inter Frame Gap Register */
+	u32	hafdup;		/* 0x.50c - Half Duplex Register */
+	u32	maxfrm;		/* 0x.510 - Maximum Frame Length Register */
+	u8	res18[12];
+	u8	gfarw_mii_regs[24];	/* See gianfar_phy.h */
+	u32	ifctrl;		/* 0x.538 - Interface control register */
+	u32	ifstat;		/* 0x.53c - Interface Status Register */
+	u32	macstnaddr1;	/* 0x.540 - Station Address Part 1 Register */
+	u32	macstnaddr2;	/* 0x.544 - Station Address Part 2 Register */
+	u32	mac01addr1;	/* 0x.548 - MAC exact match address 1, part 1 */
+	u32	mac01addr2;	/* 0x.54c - MAC exact match address 1, part 2 */
+	u32	mac02addr1;	/* 0x.550 - MAC exact match address 2, part 1 */
+	u32	mac02addr2;	/* 0x.554 - MAC exact match address 2, part 2 */
+	u32	mac03addr1;	/* 0x.558 - MAC exact match address 3, part 1 */
+	u32	mac03addr2;	/* 0x.55c - MAC exact match address 3, part 2 */
+	u32	mac04addr1;	/* 0x.560 - MAC exact match address 4, part 1 */
+	u32	mac04addr2;	/* 0x.564 - MAC exact match address 4, part 2 */
+	u32	mac05addr1;	/* 0x.568 - MAC exact match address 5, part 1 */
+	u32	mac05addr2;	/* 0x.56c - MAC exact match address 5, part 2 */
+	u32	mac06addr1;	/* 0x.570 - MAC exact match address 6, part 1 */
+	u32	mac06addr2;	/* 0x.574 - MAC exact match address 6, part 2 */
+	u32	mac07addr1;	/* 0x.578 - MAC exact match address 7, part 1 */
+	u32	mac07addr2;	/* 0x.57c - MAC exact match address 7, part 2 */
+	u32	mac08addr1;	/* 0x.580 - MAC exact match address 8, part 1 */
+	u32	mac08addr2;	/* 0x.584 - MAC exact match address 8, part 2 */
+	u32	mac09addr1;	/* 0x.588 - MAC exact match address 9, part 1 */
+	u32	mac09addr2;	/* 0x.58c - MAC exact match address 9, part 2 */
+	u32	mac10addr1;	/* 0x.590 - MAC exact match address 10, part 1*/
+	u32	mac10addr2;	/* 0x.594 - MAC exact match address 10, part 2*/
+	u32	mac11addr1;	/* 0x.598 - MAC exact match address 11, part 1*/
+	u32	mac11addr2;	/* 0x.59c - MAC exact match address 11, part 2*/
+	u32	mac12addr1;	/* 0x.5a0 - MAC exact match address 12, part 1*/
+	u32	mac12addr2;	/* 0x.5a4 - MAC exact match address 12, part 2*/
+	u32	mac13addr1;	/* 0x.5a8 - MAC exact match address 13, part 1*/
+	u32	mac13addr2;	/* 0x.5ac - MAC exact match address 13, part 2*/
+	u32	mac14addr1;	/* 0x.5b0 - MAC exact match address 14, part 1*/
+	u32	mac14addr2;	/* 0x.5b4 - MAC exact match address 14, part 2*/
+	u32	mac15addr1;	/* 0x.5b8 - MAC exact match address 15, part 1*/
+	u32	mac15addr2;	/* 0x.5bc - MAC exact match address 15, part 2*/
+	u8	res20[192];
+	struct rmon_mib	rmon;	/* 0x.680-0x.73c */
+	u32	rrej;		/* 0x.740 - Receive filer rejected packet counter */
+	u8	res21[188];
+	u32	igaddr0;	/* 0x.800 - Indivdual/Group address register 0*/
+	u32	igaddr1;	/* 0x.804 - Indivdual/Group address register 1*/
+	u32	igaddr2;	/* 0x.808 - Indivdual/Group address register 2*/
+	u32	igaddr3;	/* 0x.80c - Indivdual/Group address register 3*/
+	u32	igaddr4;	/* 0x.810 - Indivdual/Group address register 4*/
+	u32	igaddr5;	/* 0x.814 - Indivdual/Group address register 5*/
+	u32	igaddr6;	/* 0x.818 - Indivdual/Group address register 6*/
+	u32	igaddr7;	/* 0x.81c - Indivdual/Group address register 7*/
+	u8	res22[96];
+	u32	gaddr0;		/* 0x.880 - Group address register 0 */
+	u32	gaddr1;		/* 0x.884 - Group address register 1 */
+	u32	gaddr2;		/* 0x.888 - Group address register 2 */
+	u32	gaddr3;		/* 0x.88c - Group address register 3 */
+	u32	gaddr4;		/* 0x.890 - Group address register 4 */
+	u32	gaddr5;		/* 0x.894 - Group address register 5 */
+	u32	gaddr6;		/* 0x.898 - Group address register 6 */
+	u32	gaddr7;		/* 0x.89c - Group address register 7 */
+	u8	res23a[352];
+	u32	fifocfg;	/* 0x.a00 - FIFO interface config register */
+	u8	res23b[252];
+	u8	res23c[248];
+	u32	attr;		/* 0x.bf8 - Attributes Register */
+	u32	attreli;	/* 0x.bfc - Attributes Extract Length and Extract Index Register */
+	u32	rqprm0;	/* 0x.c00 - Receive queue parameters register 0 */
+	u32	rqprm1;	/* 0x.c04 - Receive queue parameters register 1 */
+	u32	rqprm2;	/* 0x.c08 - Receive queue parameters register 2 */
+	u32	rqprm3;	/* 0x.c0c - Receive queue parameters register 3 */
+	u32	rqprm4;	/* 0x.c10 - Receive queue parameters register 4 */
+	u32	rqprm5;	/* 0x.c14 - Receive queue parameters register 5 */
+	u32	rqprm6;	/* 0x.c18 - Receive queue parameters register 6 */
+	u32	rqprm7;	/* 0x.c1c - Receive queue parameters register 7 */
+	u8	res24[36];
+	u32	rfbptr0; /* 0x.c44 - Last free RxBD pointer for ring 0 */
+	u8	res24a[4];
+	u32	rfbptr1; /* 0x.c4c - Last free RxBD pointer for ring 1 */
+	u8	res24b[4];
+	u32	rfbptr2; /* 0x.c54 - Last free RxBD pointer for ring 2 */
+	u8	res24c[4];
+	u32	rfbptr3; /* 0x.c5c - Last free RxBD pointer for ring 3 */
+	u8	res24d[4];
+	u32	rfbptr4; /* 0x.c64 - Last free RxBD pointer for ring 4 */
+	u8	res24e[4];
+	u32	rfbptr5; /* 0x.c6c - Last free RxBD pointer for ring 5 */
+	u8	res24f[4];
+	u32	rfbptr6; /* 0x.c74 - Last free RxBD pointer for ring 6 */
+	u8	res24g[4];
+	u32	rfbptr7; /* 0x.c7c - Last free RxBD pointer for ring 7 */
+	u8	res24h[4];
+	u8	res24x[556];
+	u32	isrg0;		/* 0x.eb0 - Interrupt steering group 0 register */
+	u32	isrg1;		/* 0x.eb4 - Interrupt steering group 1 register */
+	u32	isrg2;		/* 0x.eb8 - Interrupt steering group 2 register */
+	u32	isrg3;		/* 0x.ebc - Interrupt steering group 3 register */
+	u8	res25[16];
+	u32	rxic0;		/* 0x.ed0 - Ring 0 Rx interrupt coalescing */
+	u32	rxic1;		/* 0x.ed4 - Ring 1 Rx interrupt coalescing */
+	u32	rxic2;		/* 0x.ed8 - Ring 2 Rx interrupt coalescing */
+	u32	rxic3;		/* 0x.edc - Ring 3 Rx interrupt coalescing */
+	u32	rxic4;		/* 0x.ee0 - Ring 4 Rx interrupt coalescing */
+	u32	rxic5;		/* 0x.ee4 - Ring 5 Rx interrupt coalescing */
+	u32	rxic6;		/* 0x.ee8 - Ring 6 Rx interrupt coalescing */
+	u32	rxic7;		/* 0x.eec - Ring 7 Rx interrupt coalescing */
+	u8	res26[32];
+	u32	txic0;		/* 0x.f10 - Ring 0 Tx interrupt coalescing */
+	u32	txic1;		/* 0x.f14 - Ring 1 Tx interrupt coalescing */
+	u32	txic2;		/* 0x.f18 - Ring 2 Tx interrupt coalescing */
+	u32	txic3;		/* 0x.f1c - Ring 3 Tx interrupt coalescing */
+	u32	txic4;		/* 0x.f20 - Ring 4 Tx interrupt coalescing */
+	u32	txic5;		/* 0x.f24 - Ring 5 Tx interrupt coalescing */
+	u32	txic6;		/* 0x.f28 - Ring 6 Tx interrupt coalescing */
+	u32	txic7;		/* 0x.f2c - Ring 7 Tx interrupt coalescing */
+	u8	res27[208];
+};
+
+/* Flags related to gianfar device features */
+#define FSL_GIANFAR_DEV_HAS_GIGABIT		0x00000001
+#define FSL_GIANFAR_DEV_HAS_COALESCE		0x00000002
+#define FSL_GIANFAR_DEV_HAS_RMON		0x00000004
+#define FSL_GIANFAR_DEV_HAS_MULTI_INTR		0x00000008
+#define FSL_GIANFAR_DEV_HAS_CSUM		0x00000010
+#define FSL_GIANFAR_DEV_HAS_VLAN		0x00000020
+#define FSL_GIANFAR_DEV_HAS_EXTENDED_HASH	0x00000040
+#define FSL_GIANFAR_DEV_HAS_MAGIC_PACKET	0x00000100
+#define FSL_GIANFAR_DEV_HAS_BD_STASHING		0x00000200
+#define FSL_GIANFAR_DEV_HAS_BUF_STASHING	0x00000400
+#define FSL_GIANFAR_DEV_HAS_TIMER		0x00000800
+
+#if (MAXGROUPS == 2)
+#define DEFAULT_MAPPING 	0xAA
+#else
+#define DEFAULT_MAPPING 	0xFF
+#endif
+
+#define ISRG_RR0	0x80000000
+#define ISRG_TR0	0x00800000
+
+/* The same driver can operate in two modes */
+/* SQ_SG_MODE: Single Queue Single Group Mode
+ * 		(Backward compatible mode)
+ * MQ_MG_MODE: Multi Queue Multi Group mode
+ */
+enum {
+	SQ_SG_MODE = 0,
+	MQ_MG_MODE
+};
+
+/* GFAR_SQ_POLLING: Single Queue NAPI polling mode
+ *	The driver supports a single pair of RX/Tx queues
+ *	per interrupt group (Rx/Tx int line). MQ_MG mode
+ *	devices have 2 interrupt groups, so the device will
+ *	have a total of 2 Tx and 2 Rx queues in this case.
+ * GFAR_MQ_POLLING: Multi Queue NAPI polling mode
+ *	The driver supports all the 8 Rx and Tx HW queues
+ *	each queue mapped by the Device Tree to one of
+ *	the 2 interrupt groups. This mode implies significant
+ *	processing overhead (CPU and controller level).
+ */
+enum gfarw_poll_mode {
+	GFAR_SQ_POLLING = 0,
+	GFAR_MQ_POLLING
+};
+
+/*
+ * Per TX queue stats
+ */
+struct tx_q_stats {
+	unsigned long tx_packets;
+	unsigned long tx_bytes;
+};
+
+/**
+ *	struct gfarw_priv_tx_q - per tx queue structure
+ *	@txlock: per queue tx spin lock
+ *	@tx_skbuff:skb pointers
+ *	@skb_curtx: to be used skb pointer
+ *	@skb_dirtytx:the last used skb pointer
+ *	@stats: bytes/packets stats
+ *	@qindex: index of this queue
+ *	@dev: back pointer to the dev structure
+ *	@grp: back pointer to the group to which this queue belongs
+ *	@tx_bd_base: First tx buffer descriptor
+ *	@cur_tx: Next free ring entry
+ *	@dirty_tx: First buffer in line to be transmitted
+ *	@tx_ring_size: Tx ring size
+ *	@num_txbdfree: number of free TxBds
+ *	@txcoalescing: enable/disable tx coalescing
+ *	@txic: transmit interrupt coalescing value
+ *	@txcount: coalescing value if based on tx frame count
+ *	@txtime: coalescing value if based on time
+ */
+struct gfarw_priv_tx_q {
+	/* cacheline 1 */
+	spinlock_t txlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
+	struct	txbd8 *tx_bd_base;
+	struct	txbd8 *cur_tx;
+	unsigned int num_txbdfree;
+	unsigned short skb_curtx;
+	unsigned short tx_ring_size;
+	struct tx_q_stats stats;
+	struct gfarw_priv_grp *grp;
+	/* cacheline 2 */
+	struct net_device *dev;
+	struct sk_buff **tx_skbuff;
+	struct	txbd8 *dirty_tx;
+	unsigned short skb_dirtytx;
+	unsigned short qindex;
+	/* Configuration info for the coalescing features */
+	unsigned int txcoalescing;
+	unsigned long txic;
+	dma_addr_t tx_bd_dma_base;
+};
+
+/*
+ * Per RX queue stats
+ */
+struct rx_q_stats {
+	unsigned long rx_packets;
+	unsigned long rx_bytes;
+	unsigned long rx_dropped;
+};
+
+
+#define NET_BYPASS_STATUS_USER_PACKET        1
+#define NET_BYPASS_STATUS_FREE_PACKET        0
+#define NET_BYPASS_STATUS_PACKET_IN_DMA     -1
+#define NET_BYPASS_STATUS_INVALID_PACKET    -101
+#define NET_BYPASS_STATUS_HANDLED_BY_KERNEL -102
+
+struct gfarw_priv_rx_pkt {
+	int status;
+	int size;
+	int offset;
+	struct rxbd8 *rxbd;
+	char reserved[128-3*sizeof(int)-sizeof(struct rxbd8 *)];
+	char frame[JUMBO_BUFFER_SIZE];
+};
+
+/**
+ *	struct gfarw_priv_rx_q - per rx queue structure
+ *	@rx_pktbuff: packet buffer to be mapped to userspace
+ *	@skb_currx: currently use skb pointer
+ *	@rx_bd_base: First rx buffer descriptor
+ *	@cur_rx: Next free rx ring entry
+ *	@qindex: index of this queue
+ *	@dev: back pointer to the dev structure
+ *	@rx_ring_size: Rx ring size
+ *	@rxcoalescing: enable/disable rx-coalescing
+ *	@rxic: receive interrupt coalescing vlaue
+ */
+#define RX_RING_SIZE (4096) // is about 36MB buffer-size
+struct gfarw_priv_rx_q {
+	struct gfarw_priv_rx_pkt *rx_pktbuff __aligned(SMP_CACHE_BYTES);
+	dma_addr_t rx_bd_dma_base;
+	struct	rxbd8 *rx_bd_base;
+	struct	rxbd8 *cur_rx;
+	struct	net_device *dev;
+	struct gfarw_priv_grp *grp;
+	struct rx_q_stats stats;
+	u16 rx_currpkt;				// index to the next packet which will be filled by DMA
+	u16 rx_freepkt;				// index to the next packet which will be free
+	u16	qindex;
+	unsigned int	rx_ring_size;  // = RX_RING_SIZE;  must not be changed (e.g. by ethtool)!!
+	/* RX Coalescing values */
+	unsigned char rxcoalescing;
+	unsigned long rxic;
+	u32 __iomem *rfbptr;
+};
+
+enum gfarw_irqinfo_id {
+	GFAR_TX = 0,
+	GFAR_RX = 1,
+	GFAR_ER = 2,
+	GFAR_NUM_IRQS = 3
+};
+
+struct gfarw_irqinfo {
+	unsigned int irq;
+	char name[GFAR_INT_NAME_MAX];
+};
+
+/**
+ *	struct gfarw_priv_grp - per group structure
+ *	@napi: the napi poll function
+ *	@priv: back pointer to the priv structure
+ *	@regs: the ioremapped register space for this group
+ *	@irqinfo: TX/RX/ER irq data for this group
+ */
+
+struct gfarw_priv_grp {
+	spinlock_t grplock __aligned(SMP_CACHE_BYTES);
+	struct	napi_struct napi_rx;
+	struct	napi_struct napi_tx;
+	struct gfarw __iomem *regs;
+	struct gfarw_priv_tx_q *tx_queue;
+	struct gfarw_priv_rx_q *rx_queue;
+	unsigned int tstat;
+	unsigned int rstat;
+
+	struct gfarw_private *priv;
+	unsigned long num_tx_queues;
+	unsigned long tx_bit_map;
+	unsigned long num_rx_queues;
+	unsigned long rx_bit_map;
+
+	struct gfarw_irqinfo *irqinfo[GFAR_NUM_IRQS];
+};
+
+#define gfarw_irq(grp, ID) \
+	((grp)->irqinfo[GFAR_##ID])
+
+enum gfarw_errata {
+	GFAR_ERRATA_74		= 0x01,
+	GFAR_ERRATA_76		= 0x02,
+	GFAR_ERRATA_A002	= 0x04,
+	GFAR_ERRATA_12		= 0x08, /* a.k.a errata eTSEC49 */
+};
+
+enum gfarw_dev_state {
+	GFAR_DOWN = 1,
+	GFAR_RESETTING
+};
+
+/* Struct stolen almost completely (and shamelessly) from the FCC enet source
+ * (Ok, that's not so true anymore, but there is a family resemblance)
+ * The GFAR buffer descriptors track the ring buffers.  The rx_bd_base
+ * and tx_bd_base always point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct gfarw_private {
+	struct device *dev;
+	struct net_device *ndev;
+	enum gfarw_errata errata;
+	unsigned int rx_buffer_size;
+
+	u16 uses_rxfcb;
+	u16 padding;
+	u32 device_flags;
+
+	/* HW time stamping enabled flag */
+	int hwts_rx_en;
+	int hwts_tx_en;
+
+	struct gfarw_priv_tx_q *tx_queue[MAX_TX_QS];
+	struct gfarw_priv_rx_q *rx_queue[MAX_RX_QS];
+	struct gfarw_priv_grp gfarwgrp[MAXGROUPS];
+
+	unsigned long state;
+
+	unsigned short mode;
+	unsigned short poll_mode;
+	unsigned int num_tx_queues;
+	unsigned int num_rx_queues;
+	unsigned int num_grps;
+	int tx_actual_en;
+
+	/* Network Statistics */
+	struct gfarw_extra_stats extra_stats;
+
+	/* PHY stuff */
+	phy_interface_t interface;
+	struct device_node *phy_node;
+	struct device_node *tbi_node;
+	struct phy_device *phydev;
+	struct mii_bus *mii_bus;
+	int oldspeed;
+	int oldduplex;
+	int oldlink;
+
+	uint32_t msg_enable;
+
+	struct work_struct reset_task;
+
+	struct platform_device *ofdev;
+	unsigned char
+		extended_hash:1,
+		bd_stash_en:1,
+		rx_filer_enable:1,
+		/* Wake-on-LAN enabled */
+		wol_en:1,
+		/* Enable priorty based Tx scheduling in Hw */
+		prio_sched_en:1,
+		/* Flow control flags */
+		pause_aneg_en:1,
+		tx_pause_en:1,
+		rx_pause_en:1;
+
+	/* The total tx and rx ring size for the enabled queues */
+	unsigned int total_tx_ring_size;
+	unsigned int total_rx_ring_size;
+
+	u32 rqueue;
+	u32 tqueue;
+
+	/* RX per device parameters */
+	unsigned int rx_stash_size;
+	unsigned int rx_stash_index;
+
+	u32 cur_filer_idx;
+
+	/* RX queue filer rule set*/
+	struct ethtool_rx_list rx_list;
+	struct mutex rx_queue_access;
+
+	/* Hash registers and their width */
+	u32 __iomem *hash_regs[16];
+	int hash_width;
+
+	/*Filer table*/
+	unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
+	unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
+
+	unsigned char f_mac[ETH_ALEN];  // MAC to filter
+	__be32 f_ipv4;                  // IPv4 to filter
+};
+
+
+static inline int gfarw_has_errata(struct gfarw_private *priv,
+				  enum gfarw_errata err)
+{
+	return priv->errata & err;
+}
+
+static inline u32 gfarw_read(unsigned __iomem *addr)
+{
+	u32 val;
+	val = ioread32be(addr);
+	return val;
+}
+
+static inline void gfarw_write(unsigned __iomem *addr, u32 val)
+{
+	iowrite32be(val, addr);
+}
+
+static inline void gfarw_write_filer(struct gfarw_private *priv,
+		unsigned int far, unsigned int fcr, unsigned int fpr)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+
+	gfarw_write(&regs->rqfar, far);
+	gfarw_write(&regs->rqfcr, fcr);
+	gfarw_write(&regs->rqfpr, fpr);
+}
+
+static inline void gfarw_read_filer(struct gfarw_private *priv,
+		unsigned int far, unsigned int *fcr, unsigned int *fpr)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+
+	gfarw_write(&regs->rqfar, far);
+	*fcr = gfarw_read(&regs->rqfcr);
+	*fpr = gfarw_read(&regs->rqfpr);
+}
+
+static inline void gfarw_write_isrg(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+	u32 __iomem *baddr = &regs->isrg0;
+	u32 isrg = 0;
+	int grp_idx, i;
+
+	for (grp_idx = 0; grp_idx < priv->num_grps; grp_idx++) {
+		struct gfarw_priv_grp *grp = &priv->gfarwgrp[grp_idx];
+
+		for_each_set_bit(i, &grp->rx_bit_map, priv->num_rx_queues) {
+			isrg |= (ISRG_RR0 >> i);
+		}
+
+		for_each_set_bit(i, &grp->tx_bit_map, priv->num_tx_queues) {
+			isrg |= (ISRG_TR0 >> i);
+		}
+
+		gfarw_write(baddr, isrg);
+
+		baddr++;
+		isrg = 0;
+	}
+}
+
+static inline int gfarw_is_dma_stopped(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+
+	return ((gfarw_read(&regs->ievent) & (IEVENT_GRSC | IEVENT_GTSC)) ==
+	       (IEVENT_GRSC | IEVENT_GTSC));
+}
+
+static inline int gfarw_is_rx_dma_stopped(struct gfarw_private *priv)
+{
+	struct gfarw __iomem *regs = priv->gfarwgrp[0].regs;
+
+	return gfarw_read(&regs->ievent) & IEVENT_GRSC;
+}
+
+static inline void gfarw_wmb(void)
+{
+#if defined(CONFIG_PPC)
+	/* The powerpc-specific eieio() is used, as wmb() has too strong
+	 * semantics (it requires synchronization between cacheable and
+	 * uncacheable mappings, which eieio() doesn't provide and which we
+	 * don't need), thus requiring a more expensive sync instruction.  At
+	 * some point, the set of architecture-independent barrier functions
+	 * should be expanded to include weaker barriers.
+	 */
+	eieio();
+#else
+	wmb(); /* order write acesses for BD (or FCB) fields */
+#endif
+}
+
+static inline void gfarw_clear_txbd_status(struct txbd8 *bdp)
+{
+	u32 lstatus = be32_to_cpu(bdp->lstatus);
+
+	lstatus &= BD_LFLAG(TXBD_WRAP);
+	bdp->lstatus = cpu_to_be32(lstatus);
+}
+
+irqreturn_t gfarw_receive(int irq, void *dev_id);
+int startup_gfarw(struct net_device *dev);
+void stop_gfarw(struct net_device *dev);
+void reset_gfarw(struct net_device *dev);
+void gfarw_mac_reset(struct gfarw_private *priv);
+void gfarw_halt(struct gfarw_private *priv);
+void gfarw_start(struct gfarw_private *priv);
+void gfarw_phy_test(struct mii_bus *bus, struct phy_device *phydev, int enable,
+		   u32 regnum, u32 read);
+void gfarw_configure_coalescing_all(struct gfarw_private *priv);
+int gfarw_set_features(struct net_device *dev, netdev_features_t features);
+
+extern const struct ethtool_ops gfar_ethtool_ops;
+
+#define MAX_FILER_CACHE_IDX (2*(MAX_FILER_IDX))
+
+#define RQFCR_PID_PRI_MASK 0xFFFFFFF8
+#define RQFCR_PID_L4P_MASK 0xFFFFFF00
+#define RQFCR_PID_VID_MASK 0xFFFFF000
+#define RQFCR_PID_PORT_MASK 0xFFFF0000
+#define RQFCR_PID_MAC_MASK 0xFF000000
+
+struct gfarw_mask_entry {
+	unsigned int mask; /* The mask value which is valid form start to end */
+	unsigned int start;
+	unsigned int end;
+	unsigned int block; /* Same block values indicate depended entries */
+};
+
+/* Represents a receive filer table entry */
+struct gfarw_filer_entry {
+	u32 ctrl;
+	u32 prop;
+};
+
+
+/* The 20 additional entries are a shadow for one extra element */
+struct filer_table {
+	u32 index;
+	struct gfarw_filer_entry fe[MAX_FILER_CACHE_IDX + 20];
+};
+
+/* The gianfar_ptp module will set this variable */
+extern int gfarw_phc_index;
+
+#endif /* __GIANFAR_H */
